<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Grist Label Designer ‚Äî Marquee Fix</title>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
            <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800;900&family=Oswald:wght@200;300;400;500;600;700&family=Roboto+Condensed:wght@300;400;700&family=Sofia+Sans+Extra+Condensed:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        *{box-sizing:border-box;margin:0;padding:0}
        html,body{height:100vh;width:100vw;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;display:flex;flex-direction:column;overflow:hidden;background:#f0f0f0;color:#333}
        button{padding:6px 10px;border:1px solid #ccc;background:#fff;border-radius:4px;cursor:pointer;font-size:14px;transition:all .2s}
        button:hover{background:#f9f9f9;border-color:#aaa}
        button:active{background:#e0e0e0}
        button:disabled{opacity:.5;cursor:not-allowed}
        input,select,textarea{width:100%;padding:6px;border:1px solid #ccc;border-radius:4px;font-size:14px}
        textarea{resize:vertical;min-height:60px}
        hr{border:none;border-top:1px solid #eee;margin:12px 0}
        #toolbar{flex-shrink:0;padding:8px;background:#fff;border-bottom:1px solid #e0e0e0;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
        #toolbar .zoom-label{font-size:14px;margin-left:auto}
        #toolbar .divider{width:1px;height:24px;background:#e0e0e0;margin:0 4px}
        #main-content{display:flex;flex-grow:1;overflow:hidden}
        #sidebar{width:320px;flex-shrink:0;background:#fdfdfd;border-right:1px solid #e0e0e0;padding:12px;overflow-y:auto;display:flex;flex-direction:column;gap:16px}
            .profile-section{background:#f5f5f5;padding:10px;border-radius:6px;border:1px solid #e0e0e0}
            .profile-section select{margin-bottom:8px}
            .profile-section .button-row{display:flex;gap:4px;margin-top:8px}
            .profile-section .button-row button{flex:1;font-size:12px;padding:4px 8px}
        #sidebar h3{font-size:16px;font-weight:600;border-bottom:1px solid #eee;padding-bottom:6px;margin-bottom:4px}
        .sidebar-section{display:flex;flex-direction:column;gap:8px}
        .sidebar-section .add-buttons{display:grid;grid-template-columns:1fr 1fr;gap:8px}
        .prop-grid{display:grid;grid-template-columns:90px 1fr;gap:8px;align-items:center}
        .prop-grid label{font-size:14px;font-weight:500}
        #properties-panel{font-size:14px}
        #btn-delete{background:#fbebeb;border-color:#d9a0a0;color:#c00;margin-top:12px}
        #btn-delete:hover{background:#f7dada}
        .button-group{display:flex;gap:4px}
        #canvas-container{flex-grow:1;display:flex;justify-content:center;align-items:center;overflow:auto;background:#e0e0e0;padding:20px;position:relative}
        #canvas-wrapper{display:inline-block;transform-origin:center center;position:relative}
            #label-canvas{background:#fff;box-shadow:0 4px 12px rgba(0,0,0,.15);position:relative;overflow:hidden}
        #marquee{position:absolute;border:1px dashed #007aff;background:rgba(0,122,255,0.08);pointer-events:none;display:none;z-index:9999}
        .label-element{position:absolute;cursor:move;border:1px solid transparent;font-size:16px;line-height:1.2;overflow:hidden;word-wrap:break-word;user-select:none;transform-origin:center center}
        .label-element.selected{border:2px dashed #007aff;box-shadow:0 0 0 1px rgba(0,122,255,.1)}
        .resize-handle{position:absolute;width:24px;height:24px;bottom:-12px;right:-12px;cursor:nwse-resize;display:none;z-index:10000;pointer-events:auto;background:transparent}
        .resize-handle-inner{position:absolute;width:12px;height:12px;background:#007aff;border:2px solid #fff;border-radius:50%;top:50%;left:50%;transform:translate(-50%,-50%);box-shadow:0 2px 4px rgba(0,0,0,.2)}
        .label-element.selected .resize-handle{display:block}
            .resize-handle.group-resize{width:28px;height:28px;bottom:-14px;right:-14px;z-index:10001}
            .resize-handle.group-resize .resize-handle-inner{background:#ff6b00;width:14px;height:14px;box-shadow:0 2px 6px rgba(255,107,0,.4)}
        .label-element img,.label-element svg{width:100%;height:100%;object-fit:contain;pointer-events:none}
        .status-message{position:fixed;top:60px;right:20px;padding:12px 16px;background:#4CAF50;color:#fff;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,.2);z-index:1000;animation:slideIn .3s ease-out}
        @keyframes slideIn{from{transform:translateX(400px);opacity:0}to{transform:translateX(0);opacity:1}}
        .status-message.error{background:#f44336}
            #mini-toolbar{display:none;gap:8px;background:#fff;padding:8px;border-bottom:1px solid #e0e0e0;flex-direction:row;align-items:center;justify-content:center;flex-shrink:0}
            #mini-toolbar button{padding:8px 12px;font-size:14px}
            #mini-toolbar select{padding:6px 8px;font-size:13px;border:1px solid #ccc;border-radius:4px;background:#fff;min-width:100px;max-width:150px}
            .widget-mode #canvas-container .label-element{pointer-events:none;cursor:default}
            .widget-mode #canvas-container{cursor:default}
    </style>
</head>
<body>
    <div id="toolbar">
        <button id="btn-clear" title="Clear Layout">üóëÔ∏è Clear</button>
        <div class="divider"></div>
        <button id="btn-print" title="Print Label">üñ®Ô∏è Print</button>
        <button id="btn-print-single" title="Print Single Label">üñ®Ô∏è Print Single</button>
            <div class="divider"></div>
            <button id="btn-rotate-canvas" title="Rotate Canvas 90¬∞ (temporary, not for print)">üîÑ Rotate</button>
        <div class="divider"></div>
        <button id="btn-duplicate" title="Duplicate Selected Elements" disabled>üìã Duplicate</button>
        <button id="btn-bring-front" title="Bring to Front" disabled>‚¨ÜÔ∏è Front</button>
        <button id="btn-send-back" title="Send to Back" disabled>‚¨áÔ∏è Back</button>
        <div class="divider"></div>
        <label for="canvas-selector" style="font-size:14px;margin:0;white-space:nowrap">Canvas:</label>
        <select id="canvas-selector" style="width:auto;padding:4px 8px;font-size:14px">
            <option value="1">Canvas 1</option>
            <option value="2" disabled>Canvas 2</option>
        </select>
        <input type="checkbox" id="canvas2-enabled" style="width:auto;margin:0 4px 0 8px" title="Enable Canvas 2">
        <label for="canvas2-enabled" style="font-size:12px;margin:0;white-space:nowrap;cursor:pointer">2</label>
        <span class="zoom-label">Zoom:</span>
        <div class="button-group">
            <button id="btn-zoom-out" title="Zoom Out">-</button>
            <button id="btn-zoom-in" title="Zoom In">+</button>
            <button id="btn-zoom-fit" title="Fit to Screen">Fit</button>
        </div>
        <span id="zoom-display">100%</span>
    </div>

    <div id="main-content">
        <div id="sidebar">
                <div class="sidebar-section profile-section">
                    <h3>Label Profile</h3>
                    <label>Size:</label>
                    <select id="profile-selector">
                        <option value="8x5">8 √ó 5 cm</option>
                    </select>
                <label>Design:</label>
                <div style="display:flex;gap:4px;align-items:center">
                    <select id="design-selector" style="flex:1">
                        <option value="default">Default</option>
                    </select>
                    <button id="btn-rename-design" title="Rename Design" style="padding:0;width:32px;font-size:14px;flex-shrink:0;display:flex;align-items:center;justify-content:center;box-sizing:border-box;line-height:1;margin:0;border:1px solid #ccc;border-radius:4px">‚úèÔ∏è</button>
                    <button id="btn-clone-design" title="Clone Design" style="padding:0;width:32px;font-size:14px;flex-shrink:0;display:flex;align-items:center;justify-content:center;box-sizing:border-box;line-height:1;margin:0;border:1px solid #ccc;border-radius:4px">üìã</button>
                </div>
                    <div class="button-row">
                        <button id="btn-add-profile">‚ûï Add Size</button>
                        <button id="btn-add-design">‚ûï Add Design</button>
                    </div>
                    <div class="button-row">
                        <button id="btn-remove-profile" style="background:#fbebeb;border-color:#d9a0a0;color:#c00">üóëÔ∏è Remove Size</button>
                        <button id="btn-remove-design" style="background:#fbebeb;border-color:#d9a0a0;color:#c00">üóëÔ∏è Remove Design</button>
                    </div>
                </div>
                <hr>
            <div class="sidebar-section">
                <h3>Add Element</h3>
                <div class="add-buttons">
                    <button class="add-element" data-type="text">üìù Text</button>
                    <button class="add-element" data-type="data">üîó Data Field</button>
                        <button class="add-element" data-type="image">üñºÔ∏è Image</button>
                    <button class="add-element" data-type="qr">üì± QR Code</button>
                    <button class="add-element" data-type="barcode">üìä Barcode</button>
                    <button class="add-element" data-type="line">‚ûñ Line</button>
                    <button class="add-element" data-type="box">‚¨ú Box</button>
                </div>
            </div>
            <hr>
            <div class="sidebar-section">
                <h3>Properties</h3>
                <div id="properties-panel">Select an element to edit its properties.</div>
            </div>
            <hr>
            <div class="sidebar-section">
                <h3>Import/Export</h3>
                <div style="display:flex;gap:8px">
                    <button id="btn-export">‚¨áÔ∏è Export</button>
                    <button id="btn-import">‚¨ÜÔ∏è Import</button>
                </div>
                <small>Tip: Ctrl/Cmd+E exports layout. Ctrl/Cmd+Z = undo, Ctrl/Cmd+Shift+Z = redo</small>
            </div>
        </div>

        <div id="canvas-container">
            <div id="canvas-wrapper">
                <div id="label-canvas"></div>
            </div>
            <div id="marquee"></div>
        </div>
    </div>

    <input id="file-import" type="file" accept="application/json" style="display:none" />

<script>
document.addEventListener('DOMContentLoaded', ()=>{

    // ---------- State ----------
    let S = [];                       // elements array
    let selectedIds = [];             // array of selected element ids (multi-select)
        let groups = [];                   // array of groups: [{id: 'group_xxx', elementIds: ['el_xxx', ...], bounds: {x, y, width, height}}]
    let z = 1;
    let R = {}, C = [];
    let drag = false, resizeMode = false, ctx = {};
        let canvasRotation = 0;           // temporary canvas rotation (0, 90, 180, 270 degrees)
        let W = 8, H = 5;                 // Current dimensions (dynamic)
        let globalSequenceCountColumn = ''; // Global count column (shared across all designs)
        const KEY = 'grist_label_layout_v2'; // Updated version for profiles
        const FONT_FAVORITES_KEY = 'grist_label_font_favorites'; // Key for font favorites
    const MAX_HISTORY = 100;

        // All available fonts for labels
        const ALL_FONTS = [
            { value: 'Arial, sans-serif', name: 'Arial' },
            { value: "'Courier New', monospace", name: 'Courier New' },
            { value: 'Consolas, monospace', name: 'Consolas' },
            { value: 'Georgia, serif', name: 'Georgia' },
            { value: "'Times New Roman', serif", name: 'Times New Roman' },
            { value: 'Verdana, sans-serif', name: 'Verdana' },
            { value: "'Trebuchet MS', sans-serif", name: 'Trebuchet MS' },
            { value: 'Impact, sans-serif', name: 'Impact' },
            { value: "'Comic Sans MS', cursive", name: 'Comic Sans MS' },
                { value: "'Montserrat', sans-serif", name: 'Montserrat' },
            { value: "'Winky Rough', sans-serif", name: 'Winky Rough' },
            { value: "'Oswald', sans-serif", name: 'Oswald' },
            { value: "'Roboto Condensed', sans-serif", name: 'Roboto Condensed' },
            { value: "'Sofia Sans Extra Condensed', sans-serif", name: 'Sofia Sans Extra Condensed' }
        ];
        
        // Load font favorites from localStorage
        let fontFavorites = [];
        try {
            const saved = localStorage.getItem(FONT_FAVORITES_KEY);
            if(saved) {
                fontFavorites = JSON.parse(saved);
            } else {
                // Default favorites
                fontFavorites = ['Arial, sans-serif', 'Verdana, sans-serif', 'Impact, sans-serif'];
            }
        } catch(e) {
            fontFavorites = ['Arial, sans-serif', 'Verdana, sans-serif', 'Impact, sans-serif'];
        }
        
        function saveFontFavorites() {
            try {
                localStorage.setItem(FONT_FAVORITES_KEY, JSON.stringify(fontFavorites));
            } catch(e) {
                console.warn('Failed to save font favorites:', e);
            }
        }
        
        function toggleFontFavorite(fontValue) {
            const index = fontFavorites.indexOf(fontValue);
            if(index === -1) {
                fontFavorites.push(fontValue);
                msg('Font added to favorites');
            } else {
                fontFavorites.splice(index, 1);
                msg('Font removed from favorites');
            }
            saveFontFavorites();
        }
        
        function generateFontOptions(currentFontFamily) {
            const favoriteFonts = ALL_FONTS.filter(f => fontFavorites.includes(f.value));
            const otherFonts = ALL_FONTS.filter(f => !fontFavorites.includes(f.value));
            
            let html = '';
            
            // Add favorites section
            if(favoriteFonts.length > 0) {
                html += '<optgroup label="‚≠ê Favorites">';
                favoriteFonts.forEach(font => {
                    const selected = currentFontFamily === font.value ? 'selected' : '';
                    html += `<option value="${font.value}" ${selected}>${font.name}</option>`;
                });
                html += '</optgroup>';
            }
            
            // Add separator if there are favorites
            if(favoriteFonts.length > 0 && otherFonts.length > 0) {
                html += '<optgroup label="All Fonts">';
            }
            
            // Add other fonts
            otherFonts.forEach(font => {
                const selected = currentFontFamily === font.value ? 'selected' : '';
                html += `<option value="${font.value}" ${selected}>${font.name}</option>`;
            });
            
            if(favoriteFonts.length > 0 && otherFonts.length > 0) {
                html += '</optgroup>';
            }
            
            return html;
        }
        
        // Profile management
        let profiles = {
            '8x5': {
                width: 8,
                height: 5,
                designs: {
                    'default': {
                        canvas1: [],
                        canvas2: [],
                        canvas2Enabled: false,
                        sequenceEnabled: false
                    }
                }
            }
        };
        let currentProfile = '8x5';
        let currentDesign = 'default';
        let currentCanvas = 1; // 1 or 2
        let lastDesignByProfile = {}; // Maps profileKey -> designKey (last selected design per profile)
        let lastCanvasByProfile = {}; // Maps profileKey -> canvasNum (last selected canvas per profile)
        let lastCanvasByDesign = {}; // Maps designKey -> canvasNum (last selected canvas per design)

        // History stacks for undo/redo (per design/canvas)
        let historyStacks = {}; // Key: "profile-design-canvas", Value: { history: [], historyIndex: -1 }

        // Search debounce timer
        let searchDebounceTimer = null;

        // Full screen detection
        let isFullScreen = true; // Default: assume full screen

    // DOM refs
    const cc = document.getElementById('canvas-container');
    const cw = document.getElementById('canvas-wrapper');
    const lc = document.getElementById('label-canvas');
    const pp = document.getElementById('properties-panel');
    const zd = document.getElementById('zoom-display');
    const bd = document.getElementById('btn-duplicate');
    const bf = document.getElementById('btn-bring-front');
    const bs = document.getElementById('btn-send-back');
    const fileInput = document.getElementById('file-import');
    const btnExport = document.getElementById('btn-export');
    const btnImport = document.getElementById('btn-import');
    const marquee = document.getElementById('marquee');
        const profileSelector = document.getElementById('profile-selector');
        const designSelector = document.getElementById('design-selector');
        const btnAddProfile = document.getElementById('btn-add-profile');
        const btnAddDesign = document.getElementById('btn-add-design');
        const btnRemoveProfile = document.getElementById('btn-remove-profile');
        const btnRemoveDesign = document.getElementById('btn-remove-design');
        const canvasSelector = document.getElementById('canvas-selector');
        const canvas2Checkbox = document.getElementById('canvas2-enabled');

    // Marquee state
    let marqueeActive = false;
    let marqueeStart = { clientX:0, clientY:0, startX:0, startY:0, containerRect:null };

    // ---------- Utilities ----------
    function msg(m, error=false, timeout=3000){
        const x = document.querySelector('.status-message'); if(x) x.remove();
        const s = document.createElement('div'); s.className = 'status-message' + (error ? ' error' : ''); s.textContent = m;
        document.body.appendChild(s); setTimeout(()=>{ if(s.parentNode) s.parentNode.removeChild(s) }, timeout);
    }

    function isGristAvailable(){ return (typeof window.grist !== 'undefined' && window.grist && typeof window.grist.getOption === 'function' && typeof window.grist.setOption === 'function'); }

        // Snap to pixel precision: convert cm to px, round to nearest pixel, convert back to cm
        const PIXELS_PER_CM = 37.795276; // 96 DPI
        function snapToPixel(valueCm){
            const pixels = valueCm * PIXELS_PER_CM;
            const roundedPixels = Math.round(pixels);
            return roundedPixels / PIXELS_PER_CM;
        }

        // Calculate bounding box for rotated element
        function getRotatedBounds(el){
            const rotation = Number(el.props.rotation) || 0;
            if(rotation === 0 || rotation === 180 || rotation === -180){
                return { width: el.width, height: el.height };
            }
            if(rotation === 90 || rotation === -90 || rotation === 270 || rotation === -270){
                return { width: el.height, height: el.width };
            }
            // For other angles, calculate bounding box
            const rad = (rotation * Math.PI) / 180;
            const cos = Math.abs(Math.cos(rad));
            const sin = Math.abs(Math.sin(rad));
            return {
                width: el.width * cos + el.height * sin,
                height: el.width * sin + el.height * cos
            };
        }

        // Get effective bounds considering rotation (for collision detection)
        function getEffectiveBounds(el){
            const bounds = getRotatedBounds(el);
            return {
                x: el.x - (bounds.width - el.width) / 2,
                y: el.y - (bounds.height - el.height) / 2,
                width: bounds.width,
                height: bounds.height
            };
        }

    function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

        // ---------- Profile Management ----------
        function updateCanvasSize(){
            const profile = profiles[currentProfile];
            if(!profile) return;
            W = profile.width;
            H = profile.height;
            lc.style.width = `${W}cm`;
            lc.style.height = `${H}cm`;
            updatePrintCSS();
            fit();
        }

        function updatePrintCSS(){
            const styleId = 'dynamic-print-css';
            let styleEl = document.getElementById(styleId);
            if(!styleEl){
                styleEl = document.createElement('style');
                styleEl.id = styleId;
                document.head.appendChild(styleEl);
            }
            const profile = profiles[currentProfile];
            if(profile){
                styleEl.textContent = `
                    @media print{
                        @page{size:${profile.width}cm ${profile.height}cm;margin:0}
                        html,body{margin:0!important;padding:0!important;width:${profile.width}cm!important;height:${profile.height}cm!important;overflow:visible!important;background:#fff!important}
                        #toolbar,#sidebar,#marquee,.status-message{display:none!important}
                        #main-content{width:${profile.width}cm!important;height:${profile.height}cm!important;overflow:visible!important;display:block!important;padding:0!important;margin:0!important}
                        #canvas-container{width:${profile.width}cm!important;height:${profile.height}cm!important;padding:0!important;margin:0!important;overflow:visible!important;background:#fff!important;display:block!important;position:static!important}
                        #canvas-wrapper{position:static!important;width:${profile.width}cm!important;height:${profile.height}cm!important;margin:0!important;padding:0!important;transform:none!important;display:block!important}
                        #label-canvas{position:static!important;width:${profile.width}cm!important;height:${profile.height}cm!important;transform:none!important;box-shadow:none!important;display:block!important;overflow:visible!important;background:#fff!important}
                            .label-element{page-break-inside:avoid!important;-webkit-print-color-adjust:exact!important;print-color-adjust:exact!important}
                        .label-element.selected{border:1px solid transparent!important;box-shadow:none!important}
                        .resize-handle{display:none!important}
                            .label-element[style*="border"]{-webkit-print-color-adjust:exact!important;print-color-adjust:exact!important}
                    }
                `;
            }
        }

        function updateProfileSelector(){
            const options = Object.keys(profiles).map(key => {
                const p = profiles[key];
                return `<option value="${key}" ${key===currentProfile?'selected':''}>${p.width} √ó ${p.height} cm</option>`;
            }).join('');
            profileSelector.innerHTML = options;
            
            // Aggiorna anche il selettore nella mini toolbar se esiste
            const miniProfileSelect = document.getElementById('mini-profile-selector');
            if (miniProfileSelect) {
                miniProfileSelect.innerHTML = options;
            }
        }

    function updateDesignSelector(){
        const profile = profiles[currentProfile];
        if(!profile) return;
        const options = Object.keys(profile.designs).map(key => {
            return `<option value="${key}" ${key===currentDesign?'selected':''}>${key}</option>`;
        }).join('');
        designSelector.innerHTML = options;
        
        // Aggiorna anche il selettore nella mini toolbar se esiste
        const miniDesignSelect = document.getElementById('mini-design-selector');
        if (miniDesignSelect) {
            miniDesignSelect.innerHTML = options;
        }
        
        updateCanvasControls();
        // Sync button heights with select
        setTimeout(() => {
            const selectHeight = designSelector.offsetHeight;
            const renameBtn = document.getElementById('btn-rename-design');
            const cloneBtn = document.getElementById('btn-clone-design');
            if(renameBtn && selectHeight) renameBtn.style.height = `${selectHeight}px`;
            if(cloneBtn && selectHeight) cloneBtn.style.height = `${selectHeight}px`;
        }, 0);
    }

        function updateCanvasControls(){
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[currentDesign]) return;
            const design = profile.designs[currentDesign];
            const canvas2Flag = design.canvas2Enabled || false;
            canvas2Checkbox.checked = canvas2Flag;
            
            // Update canvas selector options
            const canvas2Option = canvasSelector.querySelector('option[value="2"]');
            if(canvas2Option){
                canvas2Option.disabled = !canvas2Flag;
                if(!canvas2Flag && currentCanvas === 2){
                    // If disabling canvas 2 and we're on it, switch to canvas 1
                    currentCanvas = 1;
                    loadCurrentDesign();
                    render();
                    updateProps();
                }
            }
            canvasSelector.value = currentCanvas.toString();
            
            // Aggiorna anche il selettore canvas nella mini toolbar se esiste
            const miniCanvasSelect = document.getElementById('mini-canvas-selector');
            if (miniCanvasSelect) {
                // Mostra solo se canvas2 √® abilitato
                miniCanvasSelect.style.display = enabled ? 'block' : 'none';
                miniCanvasSelect.value = currentCanvas.toString();
            }
        }

        function switchProfile(profileKey){
            if(!profiles[profileKey]) return;
            // Save current design and canvas before switching
            saveCurrentDesign();
            // Save current canvas for previous profile
            if(currentProfile){
                lastCanvasByProfile[currentProfile] = currentCanvas;
            }
            // Switch profile
            currentProfile = profileKey;
            // Switch to last selected design for this profile, or first if none exists
            const lastDesign = lastDesignByProfile[profileKey];
            const designKeys = Object.keys(profiles[profileKey].designs);
            if(lastDesign && designKeys.includes(lastDesign)){
                currentDesign = lastDesign;
            } else {
                currentDesign = designKeys[0] || 'default';
            }
            // Switch to last selected canvas for this profile, or 1 if none exists
            const lastCanvas = lastCanvasByProfile[profileKey];
            if(lastCanvas === 1 || lastCanvas === 2){
                const design = profiles[profileKey].designs[currentDesign];
                // Only restore canvas 2 if it's enabled for this design
                if(lastCanvas === 2 && design && design.canvas2Enabled){
                    currentCanvas = 2;
                } else if(lastCanvas === 1){
                    currentCanvas = 1;
                } else {
                    currentCanvas = 1; // Fallback
                }
            } else {
                currentCanvas = 1; // Default to canvas 1
            }
            // Load the design
            loadCurrentDesign();
            updateCanvasSize();
            updateProfileSelector();
            updateDesignSelector();
            updateCanvasControls();
            render();
            updateProps();
        }

        function switchDesign(designKey){
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[designKey]) return;
            // Save current design before switching
            saveCurrentDesign();
            // Save current canvas for previous design
            if(currentDesign){
                lastCanvasByDesign[currentDesign] = currentCanvas;
            }
            // Switch design
            currentDesign = designKey;
            // Save this as the last selected design for current profile
            lastDesignByProfile[currentProfile] = designKey;
            // Switch to last selected canvas for this design, or 1 if none exists
            const lastCanvas = lastCanvasByDesign[designKey];
            if(lastCanvas === 1 || lastCanvas === 2){
                const design = profile.designs[designKey];
                // Only restore canvas 2 if it's enabled for this design
                if(lastCanvas === 2 && design && design.canvas2Enabled){
                    currentCanvas = 2;
                } else if(lastCanvas === 1){
                    currentCanvas = 1;
                } else {
                    currentCanvas = 1; // Fallback
                }
            } else {
                currentCanvas = 1; // Default to canvas 1
            }
            // Load the new design
            loadCurrentDesign();
            updateDesignSelector();
            updateCanvasControls();
            render();
            updateProps();
        }

        function switchCanvas(canvasNum){
            if(canvasNum !== 1 && canvasNum !== 2) return;
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[currentDesign]) return;
            const design = profile.designs[currentDesign];
            const canvas2Flag = design.canvas2Enabled || false;
            
            // If trying to switch to canvas 2 but it's disabled, disable selector instead of forcing reset
            if(canvasNum === 2 && !canvas2Flag){
                // Disable the canvas selector option instead of showing message
                const canvas2Option = canvasSelector.querySelector('option[value="2"]');
                if(canvas2Option){
                    canvas2Option.disabled = true;
                }
                canvasSelector.value = '1';
                return;
            }
            
            // Enable canvas 2 option if it was disabled
            if(canvas2Flag){
                const canvas2Option = canvasSelector.querySelector('option[value="2"]');
                if(canvas2Option){
                    canvas2Option.disabled = false;
                }
            }
            
            // Save current canvas before switching
            saveCurrentDesign();
            // Switch canvas
            currentCanvas = canvasNum;
            // Save this as the last selected canvas for current profile
            lastCanvasByProfile[currentProfile] = canvasNum;
            // Save this as the last selected canvas for current design
            lastCanvasByDesign[currentDesign] = canvasNum;
            // Load the new canvas
            loadCurrentDesign();
            canvasSelector.value = canvasNum.toString();
            render();
            updateProps();
        }

        function toggleCanvas2(enabled){
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[currentDesign]) return;
            const design = profile.designs[currentDesign];
            design.canvas2Enabled = enabled;
            // If disabling canvas 2 and we're on canvas 2, switch to canvas 1
            if(!enabled && currentCanvas === 2){
                saveCurrentDesign();
                currentCanvas = 1;
                loadCurrentDesign();
                render();
                updateProps();
            }
            updateCanvasControls();
            saveCurrentDesign();
        }

        // Helper function to save globalSequenceCountColumn to localStorage
        function saveGlobalSequenceCountColumn(){
            try {
                const saved = localStorage.getItem(KEY);
                if(saved){
                    const parsed = JSON.parse(saved);
                    if(parsed && parsed.version === 2){
                        parsed.globalSequenceCountColumn = globalSequenceCountColumn;
                        localStorage.setItem(KEY, JSON.stringify(parsed));
                    }
                } else {
                    // If no saved data exists, create new payload
                    const payloadObj = { 
                        version: 2, 
                        profiles: profiles || {},
                        currentProfile: currentProfile || '',
                        currentDesign: currentDesign || '',
                        currentCanvas: currentCanvas || 1,
                        groups: groups || [],
                        lastDesignByProfile: lastDesignByProfile || {},
                        lastCanvasByProfile: lastCanvasByProfile || {},
                        lastCanvasByDesign: lastCanvasByDesign || {},
                        globalSequenceCountColumn: globalSequenceCountColumn
                    };
                    localStorage.setItem(KEY, JSON.stringify(payloadObj));
                }
            } catch(e) {
                console.warn('Failed to save globalSequenceCountColumn:', e);
            }
        }

        // Helper function to save globalSequenceCountColumn to localStorage
        function saveGlobalSequenceCountColumn(){
            try {
                const saved = localStorage.getItem(KEY);
                if(saved){
                    const parsed = JSON.parse(saved);
                    if(parsed && parsed.version === 2){
                        parsed.globalSequenceCountColumn = globalSequenceCountColumn;
                        localStorage.setItem(KEY, JSON.stringify(parsed));
                    }
                } else {
                    // If no saved data exists, create new payload
                    const payloadObj = { 
                        version: 2, 
                        profiles: profiles || {},
                        currentProfile: currentProfile || '',
                        currentDesign: currentDesign || '',
                        currentCanvas: currentCanvas || 1,
                        groups: groups || [],
                        lastDesignByProfile: lastDesignByProfile || {},
                        lastCanvasByProfile: lastCanvasByProfile || {},
                        lastCanvasByDesign: lastCanvasByDesign || {},
                        globalSequenceCountColumn: globalSequenceCountColumn
                    };
                    localStorage.setItem(KEY, JSON.stringify(payloadObj));
                }
            } catch(e) {
                console.warn('Failed to save globalSequenceCountColumn:', e);
            }
        }

        function saveCurrentDesign(){
            const profile = profiles[currentProfile];
            if(!profile) return;
            if(!profile.designs[currentDesign]) {
                profile.designs[currentDesign] = {
                    canvas1: [],
                    canvas2: [],
                    canvas2Enabled: false,
                    sequenceEnabled: true
                };
            }
            const design = profile.designs[currentDesign];
            // Ensure sequence fields exist (backward compatibility)
            if(design.sequenceEnabled === undefined) design.sequenceEnabled = false;
            const canvasKey = `canvas${currentCanvas}`;
            design[canvasKey] = deepCopy(S);
            
            // Save to localStorage (includes globalSequenceCountColumn)
            try {
                const payloadObj = { 
                    version: 2, 
                    profiles: profiles,
                    currentProfile: currentProfile,
                    currentDesign: currentDesign,
                        currentCanvas: currentCanvas,
                        groups: groups,
                        lastDesignByProfile: lastDesignByProfile,
                        lastCanvasByProfile: lastCanvasByProfile,
                        lastCanvasByDesign: lastCanvasByDesign,
                        globalSequenceCountColumn: globalSequenceCountColumn
                };
                localStorage.setItem(KEY, JSON.stringify(payloadObj));
            } catch(e) {
                console.warn('Failed to save to localStorage:', e);
            }
        }

        function loadCurrentDesign(){
            const profile = profiles[currentProfile];
            if(!profile) return;
            if(!profile.designs[currentDesign]) {
                profile.designs[currentDesign] = {
                    canvas1: [],
                    canvas2: [],
                    canvas2Enabled: false,
                    sequenceEnabled: true
                };
            }
            const design = profile.designs[currentDesign];
            // Ensure sequence fields exist (backward compatibility)
            if(design.sequenceEnabled === undefined) design.sequenceEnabled = false;
            const canvasKey = `canvas${currentCanvas}`;
            const canvasData = design[canvasKey] || [];
            S = canvasData.map(normalizeElement);
            selectedIds = [];
            // Reset history when switching design/profile/canvas
            resetHistory();
        }

        function addProfile(){
            const width = prompt('Enter label width (cm):', '10');
            if(!width || isNaN(parseFloat(width))) return;
            const height = prompt('Enter label height (cm):', '7.5');
            if(!height || isNaN(parseFloat(height))) return;
            const w = parseFloat(width);
            const h = parseFloat(height);
            if(w <= 0 || h <= 0) { msg('Invalid dimensions', true); return; }
            const key = `${w}x${h}`;
            if(profiles[key]) { msg('Profile already exists', true); return; }
            // Save current before switching
            saveCurrentDesign();
            // Create new profile
            profiles[key] = {
                width: w,
                height: h,
                designs: {
                    'default': {
                        canvas1: [],
                        canvas2: [],
                        canvas2Enabled: false,
                        sequenceEnabled: false
                    }
                }
            };
            switchProfile(key);
            msg(`Profile ${w} √ó ${h} cm added`);
            saveCurrentDesign();
        }

        function removeProfile(){
            if(Object.keys(profiles).length <= 1){
                msg('Cannot remove the last profile', true);
                return;
            }
            if(!confirm(`Remove profile ${currentProfile}? All designs in this profile will be lost.`)) return;
            delete profiles[currentProfile];
            // Switch to first available profile
            const firstKey = Object.keys(profiles)[0];
            switchProfile(firstKey);
            msg('Profile removed');
            saveCurrentDesign();
        }

        function addDesign(){
            const name = prompt('Enter design name:', 'Design ' + (Object.keys(profiles[currentProfile].designs).length + 1));
            if(!name || !name.trim()) return;
            const designKey = name.trim();
            const profile = profiles[currentProfile];
            if(profile.designs[designKey]) { msg('Design already exists', true); return; }
            // Save current before switching
            saveCurrentDesign();
            // Create new empty design
            profile.designs[designKey] = {
                canvas1: [],
                canvas2: [],
                canvas2Enabled: false,
                        sequenceEnabled: false
                    };
            switchDesign(designKey);
            msg(`Design "${designKey}" added`);
            saveCurrentDesign();
        }

        function renameDesign(){
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[currentDesign]) return;
            const newName = prompt(`Rename design "${currentDesign}":`, currentDesign);
            if(!newName || !newName.trim()) return;
            const newKey = newName.trim();
            if(newKey === currentDesign) return; // No change
            if(profile.designs[newKey]){
                msg('Design name already exists', true);
                return;
            }
            // Save current design before renaming
            saveCurrentDesign();
            // Rename: copy design data to new key and delete old
            profile.designs[newKey] = profile.designs[currentDesign];
            delete profile.designs[currentDesign];
            // Switch to renamed design
            currentDesign = newKey;
            // Update last selected design for current profile
            lastDesignByProfile[currentProfile] = newKey;
            updateDesignSelector();
            msg(`Design renamed to "${newKey}"`);
            saveCurrentDesign();
        }

        function cloneDesign(){
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[currentDesign]) return;
            // Save current design first
            saveCurrentDesign();
            // Generate new name
            const baseName = currentDesign;
            let newKey = `${baseName} Copy`;
            let counter = 1;
            while(profile.designs[newKey]){
                newKey = `${baseName} Copy (${counter})`;
                counter++;
            }
            // Clone: deep copy the current design
            const currentDes = profile.designs[currentDesign];
            profile.designs[newKey] = {
                canvas1: deepCopy(currentDes.canvas1 || []),
                canvas2: deepCopy(currentDes.canvas2 || []),
                canvas2Enabled: currentDes.canvas2Enabled || false,
                sequenceEnabled: currentDes.sequenceEnabled || false
            };
            // Switch to cloned design
            switchDesign(newKey);
            msg(`Design cloned as "${newKey}"`);
            saveCurrentDesign();
        }

        function removeDesign(){
            const profile = profiles[currentProfile];
                if(!profile) return;
            if(Object.keys(profile.designs).length <= 1){
                msg('Cannot remove the last design', true);
                return;
            }
            if(!confirm(`Remove design "${currentDesign}"?`)) return;
                
                // Save current design before deletion
                saveCurrentDesign();
                
                // Delete the design
            delete profile.designs[currentDesign];
                
            // Switch to first available design
                const remainingDesigns = Object.keys(profile.designs);
                if(remainingDesigns.length > 0){
                    const firstKey = remainingDesigns[0];
                    currentDesign = firstKey;
                    updateDesignSelector();
                    loadCurrentDesign();
                    render();
                    updateProps();
                    resetHistory();
                }
                
            msg('Design removed');
            saveCurrentDesign();
        }

    // ---------- History (undo/redo) ----------
        function getHistoryKey(){
            return `${currentProfile}-${currentDesign}-${currentCanvas}`;
        }
        
        function getHistoryStack(){
            const key = getHistoryKey();
            if(!historyStacks[key]){
                historyStacks[key] = {
                    history: [],
                    historyIndex: -1
                };
            }
            return historyStacks[key];
        }
        
    function pushHistorySnapshot(){
            const stack = getHistoryStack();
            if(stack.historyIndex < stack.history.length - 1) {
                stack.history = stack.history.slice(0, stack.historyIndex + 1);
            }
            stack.history.push({
            data: deepCopy(S),
                sel: deepCopy(selectedIds),
                groups: deepCopy(groups)
        });
            if(stack.history.length > MAX_HISTORY) stack.history.shift();
            stack.historyIndex = stack.history.length - 1;
    }

    function resetHistory(){
            const stack = getHistoryStack();
            stack.history = [];
            stack.historyIndex = -1;
        pushHistorySnapshot();
    }

    function undo(){
            const stack = getHistoryStack();
            if(stack.historyIndex <= 0) { msg('Nothing to undo'); return; }
            stack.historyIndex--;
            const snap = stack.history[stack.historyIndex];
        S = deepCopy(snap.data);
        selectedIds = deepCopy(snap.sel);
            groups = snap.groups ? deepCopy(snap.groups) : [];
            // Recalculate group bounds after undo
            groups.forEach(group => {
                group.bounds = getGroupBounds(group.elementIds);
            });
        render();
        updateProps();
        updateBtns();
            saveCurrentDesign();
        msg('Undo');
    }

    function redo(){
            const stack = getHistoryStack();
            if(stack.historyIndex >= stack.history.length - 1) { msg('Nothing to redo'); return; }
            stack.historyIndex++;
            const snap = stack.history[stack.historyIndex];
        S = deepCopy(snap.data);
        selectedIds = deepCopy(snap.sel);
            groups = snap.groups ? deepCopy(snap.groups) : [];
            // Recalculate group bounds after redo
            groups.forEach(group => {
                group.bounds = getGroupBounds(group.elementIds);
            });
        render();
        updateProps();
        updateBtns();
            saveCurrentDesign();
        msg('Redo');
    }

    // ---------- Element normalization ----------
    function normalizeElement(el){
        if(!el) return null;
        const defaults = {
            id: `el_${Date.now()}`,
            type: 'text',
            x: 0.5, y: 0.5, width: 1.5, height: 0.5, zIndex: 0,
            props: {
                text: 'Sample Text',
                fontSize: 16, fontWeight: 'normal', fontFamily: 'Arial, sans-serif',
                textAlign: 'left', valign: 'top', color: '#000000',
                boundColumn: '', prefix:'', suffix:'', rotation:0,
                    showBorder:false, borderColor:'#000000', borderWidth:1, borderTop:true, borderRight:true, borderBottom:true, borderLeft:true,
                    borderRadiusTopLeft:0, borderRadiusTopRight:0, borderRadiusBottomRight:0, borderRadiusBottomLeft:0,
                paddingTop: 0, paddingRight: 0, paddingBottom: 0, paddingLeft: 0,
                thickness:2, format:'CODE128', displayValue:true,
                    fillColor:'#ffffff', decimals:2, asPercent:false,
                    lineHeight: 1.2, textOverflow: 'clip'
            }
        };

        // Merge top-level / props
        const base = Object.assign({}, defaults, el);
        base.props = Object.assign({}, defaults.props, el && el.props ? el.props : {});

        // If old single padding exists (legacy data), convert to sides
        if(base.props.padding !== undefined && !isNaN(Number(base.props.padding))){
            const v = Number(base.props.padding);
            base.props.paddingTop = base.props.paddingTop !== undefined ? Number(base.props.paddingTop) : v;
            base.props.paddingRight = base.props.paddingRight !== undefined ? Number(base.props.paddingRight) : v;
            base.props.paddingBottom = base.props.paddingBottom !== undefined ? Number(base.props.paddingBottom) : v;
            base.props.paddingLeft = base.props.paddingLeft !== undefined ? Number(base.props.paddingLeft) : v;
        } else {
            base.props.paddingTop = Number(base.props.paddingTop) || 0;
            base.props.paddingRight = Number(base.props.paddingRight) || 0;
            base.props.paddingBottom = Number(base.props.paddingBottom) || 0;
            base.props.paddingLeft = Number(base.props.paddingLeft) || 0;
        }

        base.x = Number(base.x) || 0;
        base.y = Number(base.y) || 0;
        base.width = Number(base.width) || 1;
        base.height = Number(base.height) || 1;
        base.zIndex = Number(base.zIndex) || 0;
        base.props.fontSize = Number(base.props.fontSize) || 16;
            base.props.lineHeight = Number(base.props.lineHeight) || 1.2;
        base.props.decimals = Number(base.props.decimals) || 0;
        base.props.thickness = Number(base.props.thickness) || 2;
        base.props.borderWidth = Number(base.props.borderWidth) || 1;
            base.props.borderRadiusTopLeft = Number(base.props.borderRadiusTopLeft) || 0;
            base.props.borderRadiusTopRight = Number(base.props.borderRadiusTopRight) || 0;
            base.props.borderRadiusBottomRight = Number(base.props.borderRadiusBottomRight) || 0;
            base.props.borderRadiusBottomLeft = Number(base.props.borderRadiusBottomLeft) || 0;
        base.props.displayValue = (base.props.displayValue !== false);
        base.props.asPercent = !!base.props.asPercent;
        base.props.rotation = Number(base.props.rotation) || 0;
        base.props.valign = base.props.valign || 'top';
        base.props.prefix = base.props.prefix || '';
        base.props.suffix = base.props.suffix || '';
        base.props.showBorder = !!base.props.showBorder;
        base.props.borderColor = base.props.borderColor || '#000000';
            // Default border sides to true if showBorder is true, otherwise false
            if(base.props.showBorder){
                base.props.borderTop = base.props.borderTop !== undefined ? !!base.props.borderTop : true;
                base.props.borderRight = base.props.borderRight !== undefined ? !!base.props.borderRight : true;
                base.props.borderBottom = base.props.borderBottom !== undefined ? !!base.props.borderBottom : true;
                base.props.borderLeft = base.props.borderLeft !== undefined ? !!base.props.borderLeft : true;
            } else {
                base.props.borderTop = false;
                base.props.borderRight = false;
                base.props.borderBottom = false;
                base.props.borderLeft = false;
            }
        return base;
    }

    // ---------- Rendering ----------
    function render(){
        lc.innerHTML = '';
        
        // Sequence mode is always enabled
        const profile = profiles[currentProfile];
        const design = profile && profile.designs[currentDesign] ? profile.designs[currentDesign] : null;
        const sequenceCountColumn = globalSequenceCountColumn || '';
        const canvas2Flag = design && design.canvas2Enabled ? true : false;
        
        let countToRender = 1;
        const MAX_PREVIEW_LABELS = 50;
        const labelSpacing = 1.0; // cm spacing between labels (increased for better visibility)
        
        if(sequenceCountColumn && R && Object.prototype.hasOwnProperty.call(R, sequenceCountColumn)){
            const countRaw = R[sequenceCountColumn];
            const count = Math.max(0, Math.floor(Number(countRaw)));
            countToRender = Math.min(count, MAX_PREVIEW_LABELS);
        }
        
        // Helper function to render elements for a specific canvas and sequence index
        function renderElementsForCanvas(canvasData, sequenceIndex, baseOffsetY){
            const sorted = canvasData.map(normalizeElement).slice().sort((a,b)=> (a.zIndex||0) - (b.zIndex||0));
            sorted.forEach(el=>{
            const d = document.createElement('div');
            d.classList.add('label-element');
            d.dataset.id = el.id;
            d.style.left = `${el.x}cm`;
            d.style.top = `${el.y + baseOffsetY}cm`;
            d.style.width = `${el.width}cm`;
            d.style.height = `${el.height}cm`;
            // Ensure z-index is set properly for sequence mode
            // Base z-index from element, but ensure it's at least 0 for interactivity
            const baseZIndex = el.zIndex || 0;
            d.style.zIndex = baseZIndex >= 0 ? baseZIndex : 0;
            d.style.fontSize = `${el.props.fontSize || 16}px`;
                const fontWeight = el.props.fontWeight;
                if(typeof fontWeight === 'number'){
                    d.style.fontWeight = fontWeight;
                } else {
                    d.style.fontWeight = fontWeight || 'normal';
                }
            d.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                d.style.lineHeight = el.props.lineHeight !== undefined ? String(el.props.lineHeight) : '1.2';
            const justifyMap = { left: 'flex-start', center: 'center', right: 'flex-end' };
            const alignMap = { top: 'flex-start', middle: 'center', bottom: 'flex-end' };
            if(el.type !== 'line'){
                d.style.display = 'flex';
                d.style.alignItems = alignMap[el.props.valign] || 'flex-start';
                d.style.justifyContent = justifyMap[el.props.textAlign] || 'flex-start';
                    // Use pre-wrap to preserve line breaks from textarea
                    if(el.type === 'text' || el.type === 'data'){
                        d.style.whiteSpace = 'pre-wrap';
                    } else {
                d.style.whiteSpace = 'normal';
                    }
            } else {
                d.style.display = '';
                d.style.whiteSpace = '';
            }
            d.style.textAlign = el.props.textAlign || 'left';
            d.style.color = el.props.color || '#000000';
            d.style.boxSizing = 'border-box';
            const rotation = Number(el.props.rotation) || 0;
            d.style.transform = `rotate(${rotation}deg)`;
            d.style.transformOrigin = 'center center';

            // padding sides applied in cm if element is text or data (default 0)
            if((el.type === 'text' || el.type === 'data')){
                const pt = Number.isFinite(Number(el.props.paddingTop)) ? Number(el.props.paddingTop) : 0;
                const pr = Number.isFinite(Number(el.props.paddingRight)) ? Number(el.props.paddingRight) : 0;
                const pb = Number.isFinite(Number(el.props.paddingBottom)) ? Number(el.props.paddingBottom) : 0;
                const pl = Number.isFinite(Number(el.props.paddingLeft)) ? Number(el.props.paddingLeft) : 0;
                d.style.padding = `${pt}cm ${pr}cm ${pb}cm ${pl}cm`;
            } else {
                d.style.padding = '';
            }

                // border - apply individual sides
            if(el.props.showBorder && el.type !== 'box'){
                    const borderWidth = `${Number(el.props.borderWidth)||1}px`;
                    const borderColor = el.props.borderColor || '#000';
                    const borderStyle = 'solid';
                    
                    // Apply borders only to enabled sides
                    d.style.borderTop = (el.props.borderTop !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                    d.style.borderRight = (el.props.borderRight !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                    d.style.borderBottom = (el.props.borderBottom !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                    d.style.borderLeft = (el.props.borderLeft !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                    
                    // Apply border radius (individual corners)
                    const brTL = Number(el.props.borderRadiusTopLeft) || 0;
                    const brTR = Number(el.props.borderRadiusTopRight) || 0;
                    const brBR = Number(el.props.borderRadiusBottomRight) || 0;
                    const brBL = Number(el.props.borderRadiusBottomLeft) || 0;
                    if(brTL > 0 || brTR > 0 || brBR > 0 || brBL > 0){
                        d.style.borderRadius = `${brTL}px ${brTR}px ${brBR}px ${brBL}px`;
            } else {
                        d.style.borderRadius = '';
                    }
                } else {
                    // Don't apply transparent border to lines - they use thickness for height
                    if(el.type !== 'box' && el.type !== 'line') d.style.border = '1px solid transparent';
            }

                // Apply border radius for box elements (independent of showBorder)
                if(el.type === 'box'){
                    const brTL = Number(el.props.borderRadiusTopLeft) || 0;
                    const brTR = Number(el.props.borderRadiusTopRight) || 0;
                    const brBR = Number(el.props.borderRadiusBottomRight) || 0;
                    const brBL = Number(el.props.borderRadiusBottomLeft) || 0;
                    if(brTL > 0 || brTR > 0 || brBR > 0 || brBL > 0){
                        d.style.borderRadius = `${brTL}px ${brTR}px ${brBR}px ${brBL}px`;
                    } else {
                        d.style.borderRadius = '';
                    }
            }

            // content
            switch(el.type){
                case 'text': {
                    const span = document.createElement('div');
                    span.style.display='block';
                    span.style.pointerEvents='none';
                    
                    // Set whiteSpace and width based on textOverflow mode
                    const overflowMode = el.props.textOverflow || 'clip';
                    if(overflowMode === 'squeeze'){
                        span.style.whiteSpace = 'nowrap'; // No wrapping for squeeze
                        span.style.width = 'auto'; // Allow natural text width for squeeze
                        span.style.overflow = 'visible'; // Don't clip compressed text
                    } else {
                        span.style.width = '100%';
                        span.style.overflow = 'hidden';
                        span.style.whiteSpace = 'pre-wrap'; // Allow wrapping for clip and auto-scale
                    }
                    span.style.wordWrap='break-word';
                    
                    span.textContent = getData(el, sequenceIndex);
                    // Copy font styles to span for overflow calculation
                    span.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                    span.style.fontSize = (el.props.fontSize || 16) + 'px';
                    const fontWeight = el.props.fontWeight;
                    if(typeof fontWeight === 'number'){
                        span.style.fontWeight = fontWeight;
                    } else {
                        span.style.fontWeight = fontWeight || 'normal';
                    }
                    span.style.lineHeight = el.props.lineHeight !== undefined ? String(el.props.lineHeight) : '1.2';
                    span.style.color = el.props.color || '#000000';
                    
                    d.appendChild(span);
                    
                    // Apply text overflow handling after element is in DOM
                    requestAnimationFrame(() => {
                        const containerWidth = d.offsetWidth;
                        const containerHeight = d.offsetHeight;
                        applyTextOverflow(span, el, containerWidth, containerHeight, false);
                    });
                    break;
                }
                case 'data': {
                    const span = document.createElement('div');
                    span.style.display='block';
                    span.style.pointerEvents='none';
                    
                    // Set whiteSpace and width based on textOverflow mode
                    const overflowMode = el.props.textOverflow || 'clip';
                    if(overflowMode === 'squeeze'){
                        span.style.whiteSpace = 'nowrap'; // No wrapping for squeeze
                        span.style.width = 'auto'; // Allow natural text width for squeeze
                        span.style.overflow = 'visible'; // Don't clip compressed text
                    } else {
                        span.style.width = '100%';
                        span.style.overflow = 'hidden';
                        span.style.whiteSpace = 'pre-wrap'; // Allow wrapping for clip and auto-scale
                    }
                    span.style.wordWrap='break-word';
                    
                    span.textContent = getData(el, sequenceIndex);
                    // Copy font styles to span for overflow calculation
                    span.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                    span.style.fontSize = (el.props.fontSize || 16) + 'px';
                    const fontWeight = el.props.fontWeight;
                    if(typeof fontWeight === 'number'){
                        span.style.fontWeight = fontWeight;
                    } else {
                        span.style.fontWeight = fontWeight || 'normal';
                    }
                    span.style.lineHeight = el.props.lineHeight !== undefined ? String(el.props.lineHeight) : '1.2';
                    span.style.color = el.props.color || '#000000';
                    
                    d.appendChild(span);
                    
                    // Apply text overflow handling after element is in DOM
                    requestAnimationFrame(() => {
                        const containerWidth = d.offsetWidth;
                        const containerHeight = d.offsetHeight;
                        applyTextOverflow(span, el, containerWidth, containerHeight, false);
                    });
                    break;
                }
                case 'line':
                    d.style.backgroundColor = el.props.color || '#000000';
                    d.style.height = `${el.props.thickness || 2}px`;
                    d.style.width = `${el.width}cm`;
                        d.style.border = 'none'; // No border for lines - thickness controls height
                    break;
                case 'box':
                        const boxThickness = el.props.thickness !== undefined ? Number(el.props.thickness) : 2;
                        if(boxThickness > 0){
                            d.style.border = `${boxThickness}px solid ${el.props.color || '#000000'}`;
                            d.style.borderWidth = `${boxThickness}px`;
                        } else {
                            d.style.border = 'none';
                            d.style.borderWidth = '0';
                            d.style.borderStyle = 'none';
                            d.style.borderColor = 'transparent';
                        }
                    d.style.backgroundColor = el.props.fillColor || 'transparent';
                    break;
                case 'qr': {
                    const c = getData(el, sequenceIndex);
                    const q = document.createElement('img');
                    const dpi = 37.795276;
                    const qs = Math.min(el.width, el.height) * dpi;
                    q.src = `https://api.qrserver.com/v1/create-qr-code/?size=${Math.round(qs)}x${Math.round(qs)}&data=${encodeURIComponent(c)}`;
                    q.style.pointerEvents='none';
                    q.style.width='100%';
                    q.style.height='100%';
                    q.style.objectFit='contain';
                    d.appendChild(q);
                    break;
                }
                case 'barcode': {
                    const c = getData(el, sequenceIndex) || '';
                    let prefix = el.props.prefix || '';
                    let suffix = el.props.suffix || '';
                    
                    // Apply sequence placeholder to prefix and suffix
                    prefix = replaceColumnSyntax(prefix, el);
                    prefix = applySequencePlaceholder(prefix, sequenceIndex);
                    suffix = replaceColumnSyntax(suffix, el);
                    suffix = applySequencePlaceholder(suffix, sequenceIndex);
                    
                    // Combine prefix + code + suffix into the barcode value
                    const barcodeValue = prefix + String(c) + suffix;
                    
                    // Calculate dimensions considering padding and borders FIRST
                    const paddingTop = (Number(el.props.paddingTop) || 0) * PIXELS_PER_CM;
                    const paddingBottom = (Number(el.props.paddingBottom) || 0) * PIXELS_PER_CM;
                    const paddingLeft = (Number(el.props.paddingLeft) || 0) * PIXELS_PER_CM;
                    const paddingRight = (Number(el.props.paddingRight) || 0) * PIXELS_PER_CM;
                    const borderWidth = (Number(el.props.thickness) || 0);
                    
                    const containerWidthPx = el.width * PIXELS_PER_CM;
                    const containerHeightPx = el.height * PIXELS_PER_CM;
                    const availableWidth = containerWidthPx - paddingLeft - paddingRight - (borderWidth * 2);
                    const availableHeight = containerHeightPx - paddingTop - paddingBottom - (borderWidth * 2);
                    
                    // Create SVG for barcode - fill full container
                    const sv = document.createElementNS('http://www.w3.org/2000/svg','svg');
                    sv.style.pointerEvents='none';
                    sv.style.width = '100%';
                    sv.style.height = '100%';
                    sv.style.display = 'block';
                    sv.style.overflow = 'visible';
                    d.appendChild(sv);
                    
                    try{
                        const barcodeWidth = Math.max(50, availableWidth);
                        const pxHeight = availableHeight; // Use full available height, no minimum
                        
                        // Calculate width per bar based on available width (estimate ~50 bars for typical barcode)
                        const estimatedBars = 50;
                        const widthPerBar = Math.max(1, barcodeWidth / estimatedBars);
                        
                        // Set explicit SVG dimensions
                        sv.setAttribute('width', barcodeWidth.toString());
                        sv.setAttribute('height', pxHeight.toString());
                        sv.setAttribute('viewBox', `0 0 ${barcodeWidth} ${pxHeight}`);
                        sv.setAttribute('preserveAspectRatio', 'none'); // No aspect ratio preservation - fill completely
                        
                        // Generate barcode with prefix + code + suffix included
                        JsBarcode(sv, barcodeValue, {
                            format: el.props.format || "CODE128",
                            displayValue: el.props.displayValue !== false,
                            width: widthPerBar,
                            height: pxHeight,
                            margin: 0
                        });
                    }catch(err){
                        sv.innerHTML = `<text x="10" y="20" fill="red" font-size="12">Invalid barcode</text>`;
                        console.error("Barcode Error:",err);
                    }
                    break;
                }
                    case 'image': {
                        const img = document.createElement('img');
                        img.style.pointerEvents='none';
                        img.style.width='100%';
                        img.style.height='100%';
                        img.style.objectFit = el.props.objectFit || 'contain';
                        
                        // Build Imgur URL from Grist column value
                        let imageUrl = '';
                        if(el.props.boundColumn && R && Object.prototype.hasOwnProperty.call(R, el.props.boundColumn)){
                            const imgurId = R[el.props.boundColumn];
                            if(imgurId){
                                const id = String(imgurId).trim();
                                if(id){
                                    // Construct Imgur URL: https://i.imgur.com/{id}.jpg
                                    // If the value already contains http/https, use it as-is
                                    if(id.startsWith('http://') || id.startsWith('https://')){
                                        imageUrl = id;
                                    } else {
                                        // Remove any existing extension and add .jpg
                                        const cleanId = id.replace(/\.(jpg|jpeg|png|gif|webp)$/i, '');
                                        imageUrl = `https://i.imgur.com/${cleanId}.jpg`;
                                    }
                                }
                            }
                        }
                        
                        if(imageUrl){
                            img.src = imageUrl;
                            img.onerror = function(){
                                img.style.display = 'none';
                                const errorDiv = document.createElement('div');
                                errorDiv.style.width = '100%';
                                errorDiv.style.height = '100%';
                                errorDiv.style.display = 'flex';
                                errorDiv.style.alignItems = 'center';
                                errorDiv.style.justifyContent = 'center';
                                errorDiv.style.color = '#999';
                                errorDiv.style.fontSize = '12px';
                                errorDiv.textContent = 'Image not found';
                                d.appendChild(errorDiv);
                            };
                        } else {
                            // Show placeholder when no image
                            img.style.display = 'none';
                            const placeholder = document.createElement('div');
                            placeholder.style.width = '100%';
                            placeholder.style.height = '100%';
                            placeholder.style.display = 'flex';
                            placeholder.style.alignItems = 'center';
                            placeholder.style.justifyContent = 'center';
                            placeholder.style.color = '#ccc';
                            placeholder.style.fontSize = '12px';
                            placeholder.style.border = '1px dashed #ccc';
                            placeholder.textContent = 'No image';
                            d.appendChild(placeholder);
                        }
                        d.appendChild(img);
                        break;
                    }
                default:
                    d.innerText = el.props.text || '';
            }

            // selection visuals
            if(selectedIds.includes(el.id)){
                d.classList.add('selected');
                    const group = getGroupForElement(el.id);
                    
                    // Show resize handle for groups when all group elements are selected
                    if(group){
                        const allGroupSelected = group.elementIds.every(id => selectedIds.includes(id));
                        if(allGroupSelected){
                            // Show resize handle on the element that's at the bottom-right of the group
                            const groupBounds = getGroupBounds(group.elementIds);
                            // Find element closest to bottom-right corner
                            let maxDistance = -1;
                            let bottomRightElement = null;
                            group.elementIds.forEach(eid => {
                                const elem = S.find(e => e.id === eid);
                                if(elem){
                                    const distance = (elem.x + elem.width) + (elem.y + elem.height);
                                    if(distance > maxDistance){
                                        maxDistance = distance;
                                        bottomRightElement = elem;
                                    }
                                }
                            });
                            // Show resize handle on the bottom-right element
                            if(bottomRightElement && bottomRightElement.id === el.id){
                                const h = document.createElement('div');
                                h.classList.add('resize-handle', 'group-resize');
                                h.title = 'Resize group (maintains proportions)';
                                d.appendChild(h);
                            }
                        } else if(selectedIds.length === 1 && selectedIds[0] === el.id){
                            // Show resize handle if only this element is selected (will resize whole group)
                            const h = document.createElement('div');
                            h.classList.add('resize-handle', 'group-resize');
                            h.title = 'Resize group (maintains proportions)';
                            const inner = document.createElement('div');
                            inner.classList.add('resize-handle-inner');
                            h.appendChild(inner);
                            d.appendChild(h);
                        }
                        // Add elegant group indicator with subtle styling
                        d.style.borderColor = '#ff6b00';
                        d.style.borderStyle = 'dashed';
                        d.style.borderWidth = '2px';
                        d.style.borderRadius = '3px';
                        d.style.boxShadow = '0 0 0 1px rgba(255,107,0,0.15), inset 0 0 0 1px rgba(255,107,0,0.05)';
                        d.style.opacity = '0.9';
                    } else {
                        // Regular resize handle for non-grouped elements
                const h = document.createElement('div');
                h.classList.add('resize-handle');
                const inner = document.createElement('div');
                inner.classList.add('resize-handle-inner');
                h.appendChild(inner);
                d.appendChild(h);
                    }
            }

            lc.appendChild(d);
            });
        }
        
        // Always show only the current canvas being edited (sequence 1 only)
        // Sequence mode is used only for printing, not for canvas preview
        // Show only the canvas that the user is currently working on
        renderElementsForCanvas(S, 1, 0);
        // Reset container height to single label height
        lc.style.height = `${H}cm`;
    }

        // Helper function to apply text overflow handling
        function applyTextOverflow(span, el, containerWidth, containerHeight, isPrintMode){
            const overflowMode = el.props.textOverflow || 'clip';
            if(overflowMode === 'clip') return; // Default behavior, no changes needed
            
            // Get the parent container (d element)
            const container = span.parentElement;
            
            if(overflowMode === 'squeeze'){
                // Horizontal squeeze: compress text horizontally when it's too wide
                // Calculate available width (accounting for padding and borders)
                const safetyMargin = 2;
                let availableWidth;
                if(isPrintMode){
                    // In print mode, convert padding from cm to pixels
                    const paddingLeft = (Number(el.props.paddingLeft) || 0) * PIXELS_PER_CM;
                    const paddingRight = (Number(el.props.paddingRight) || 0) * PIXELS_PER_CM;
                    const borderWidth = (el.props.showBorder && el.props.borderWidth) ? Number(el.props.borderWidth) : 0;
                    const borderLeft = (el.props.borderLeft !== false) ? borderWidth : 0;
                    const borderRight = (el.props.borderRight !== false) ? borderWidth : 0;
                    availableWidth = containerWidth - paddingLeft - paddingRight - borderLeft - borderRight - safetyMargin;
                } else {
                    const paddingLeft = Number(el.props.paddingLeft) || 0;
                    const paddingRight = Number(el.props.paddingRight) || 0;
                    const borderWidth = (el.props.showBorder && el.props.borderWidth) ? Number(el.props.borderWidth) : 0;
                    const borderLeft = (el.props.borderLeft !== false) ? borderWidth : 0;
                    const borderRight = (el.props.borderRight !== false) ? borderWidth : 0;
                    availableWidth = containerWidth - paddingLeft - paddingRight - borderLeft - borderRight - safetyMargin;
                }
                
                if(availableWidth <= 0) return;
                
                // For print mode, execute synchronously; for normal mode, use requestAnimationFrame
                const executeSqueeze = () => {
                    // Create a measurement div to check overflow
                    const measureDiv = document.createElement('div');
                    measureDiv.textContent = span.textContent;
                    measureDiv.style.position = 'absolute';
                    measureDiv.style.visibility = 'hidden';
                    measureDiv.style.whiteSpace = 'nowrap';
                    measureDiv.style.width = 'auto';
                    measureDiv.style.height = 'auto';
                    measureDiv.style.overflow = 'visible';
                    measureDiv.style.maxWidth = 'none';
                    measureDiv.style.padding = '0';
                    measureDiv.style.margin = '0';
                    measureDiv.style.border = 'none';
                    // Copy all relevant styles from span
                    measureDiv.style.fontFamily = span.style.fontFamily || el.props.fontFamily || 'Arial, sans-serif';
                    measureDiv.style.fontSize = span.style.fontSize || (el.props.fontSize || 16) + 'px';
                    measureDiv.style.fontWeight = span.style.fontWeight || el.props.fontWeight || 'normal';
                    measureDiv.style.lineHeight = span.style.lineHeight || el.props.lineHeight || '1.2';
                    measureDiv.style.letterSpacing = span.style.letterSpacing || 'normal';
                    document.body.appendChild(measureDiv);
                    
                    // Measure text width
                    const textWidth = Math.max(measureDiv.scrollWidth, measureDiv.offsetWidth);
                    document.body.removeChild(measureDiv);
                    
                    if(textWidth > availableWidth){
                        // Calculate scale factor
                        const scaleX = Math.max(0.1, (availableWidth / textWidth));
                        // Apply horizontal squeeze with transform-origin based on text alignment
                        const textAlign = el.props.textAlign || 'left';
                        let transformOrigin = 'left center';
                        if(textAlign === 'center') transformOrigin = 'center center';
                        else if(textAlign === 'right') transformOrigin = 'right center';
                        
                        // Apply scaleX (rotation is handled by parent container)
                        span.style.transform = `scaleX(${scaleX})`;
                        span.style.transformOrigin = transformOrigin;
                        
                        // Ensure span can show all compressed text
                        span.style.width = 'auto';
                        span.style.overflow = 'visible';
                        span.style.maxWidth = 'none';
                        
                        // Allow container to show compressed text
                        if(container){
                            container.style.overflow = 'visible';
                        }
                    } else {
                        // Reset transform if text fits
                        span.style.transform = '';
                        span.style.transformOrigin = '';
                    }
                };
                
                if(isPrintMode){
                    // Execute synchronously for print
                    executeSqueeze();
                } else {
                    // Use requestAnimationFrame for normal rendering
                    requestAnimationFrame(executeSqueeze);
                }
                return;
            }
            
            // For auto-scale: check bottom overflow and reduce font size
            // Calculate available height (accounting for padding and borders)
            const safetyMargin = 2;
            let availableHeight;
            
            // Calculate padding and borders in pixels
            const paddingTop = (Number(el.props.paddingTop) || 0) * PIXELS_PER_CM;
            const paddingBottom = (Number(el.props.paddingBottom) || 0) * PIXELS_PER_CM;
            const borderWidth = (el.props.showBorder && el.props.borderWidth) ? Number(el.props.borderWidth) : 0;
            const borderTop = (el.props.borderTop !== false) ? borderWidth : 0;
            const borderBottom = (el.props.borderBottom !== false) ? borderWidth : 0;
            
            // In print mode, padding is applied to container via CSS (in cm)
            // containerHeight is the total element height in pixels
            // The span is inside the container, so available height = containerHeight - padding - border
            availableHeight = containerHeight - paddingTop - paddingBottom - borderTop - borderBottom - safetyMargin;
            
            if(availableHeight <= 0) return; // No space available
            
            // Function to apply auto-scale
            const executeAutoScale = () => {
                // Get the span width
                let spanWidth;
                if(isPrintMode){
                    // In print mode, calculate from containerWidth minus padding/border
                    const paddingLeft = (Number(el.props.paddingLeft) || 0) * PIXELS_PER_CM;
                    const paddingRight = (Number(el.props.paddingRight) || 0) * PIXELS_PER_CM;
                    const borderLeft = (el.props.borderLeft !== false) ? borderWidth : 0;
                    const borderRight = (el.props.borderRight !== false) ? borderWidth : 0;
                    spanWidth = containerWidth - paddingLeft - paddingRight - borderLeft - borderRight;
                } else {
                    spanWidth = span.offsetWidth || containerWidth;
                }
                
                if(spanWidth <= 0) return;
                
                // Get the actual height of the span
                const spanHeight = span.scrollHeight || 0;
                const spanClientHeight = span.clientHeight || span.offsetHeight || 0;
                
                // Check if there's bottom overflow
                const hasBottomOverflow = spanHeight > spanClientHeight || spanHeight > availableHeight;
                
                if(!hasBottomOverflow) return; // No overflow, keep default behavior
                
                // Text overflows at bottom - reduce font size
                let fontSize = Number(el.props.fontSize) || 16;
                const minFontSize = 6;
                
                // Create a measurement div with same styles and wrapping
                const measureDiv = document.createElement('div');
                measureDiv.textContent = span.textContent;
                measureDiv.style.position = 'absolute';
                measureDiv.style.visibility = 'hidden';
                measureDiv.style.width = spanWidth + 'px';
                measureDiv.style.height = 'auto';
                measureDiv.style.overflow = 'visible';
                measureDiv.style.maxHeight = 'none';
                measureDiv.style.padding = '0';
                measureDiv.style.margin = '0';
                measureDiv.style.border = 'none';
                // Copy all relevant styles from span
                measureDiv.style.fontFamily = span.style.fontFamily || el.props.fontFamily || 'Arial, sans-serif';
                measureDiv.style.fontWeight = span.style.fontWeight || el.props.fontWeight || 'normal';
                measureDiv.style.lineHeight = span.style.lineHeight || el.props.lineHeight || '1.2';
                measureDiv.style.whiteSpace = span.style.whiteSpace || 'pre-wrap';
                measureDiv.style.wordWrap = span.style.wordWrap || 'break-word';
                document.body.appendChild(measureDiv);
                
                // Reduce font size until text fits within available height
                while(measureDiv.scrollHeight > availableHeight && fontSize > minFontSize){
                    fontSize -= 0.5;
                    measureDiv.style.fontSize = fontSize + 'px';
                }
                
                // Apply the calculated font size
                span.style.fontSize = fontSize + 'px';
                document.body.removeChild(measureDiv);
            };
            
            // Check if text overflows at the bottom (after natural wrapping)
            if(isPrintMode){
                // For print mode, execute immediately
                executeAutoScale();
            } else {
                // Use requestAnimationFrame for normal rendering
                requestAnimationFrame(() => {
                    requestAnimationFrame(executeAutoScale);
                });
            }
        }
        
        // Helper function to replace **column** syntax with actual data
        function replaceColumnSyntax(str, el){
            if(!str || typeof str !== 'string' || !R || typeof R !== 'object') return str;
            return str.replace(/\*\*([^*]+)\*\*/g, (match, columnId) => {
                const trimmedColumnId = columnId.trim();
                if(Object.prototype.hasOwnProperty.call(R, trimmedColumnId)){
                    let v = R[trimmedColumnId];
                    if(v === null || v === undefined) return '';
                    // Format numbers if it's a data field
                    if(el && el.type === 'data' && typeof v === 'number'){
                        const dec = (el.props.decimals !== undefined) ? Number(el.props.decimals) : 2;
                        const pct = !!el.props.asPercent;
                        return fmt(v, dec, pct);
                    }
                    return String(v);
                }
                // Return the original match if column not found (so user can see what's missing)
                return match;
        });
    }

    function applySequencePlaceholder(str, sequenceIndex){
        if(!str || typeof str !== 'string') return str;
        return str.replace(/\*\*sequence\*\*/g, String(sequenceIndex));
    }

    function getData(el, sequenceIndex = 1){
            let text = el.props.text || '';
            let prefix = el.props.prefix || '';
            let suffix = el.props.suffix || '';
            
            // Handle **column** syntax for text, data, and barcode fields
            if(el.type === 'text' || el.type === 'data' || el.type === 'barcode'){
                // Process text, prefix, and suffix for **column** syntax
                text = replaceColumnSyntax(text, el);
                prefix = replaceColumnSyntax(prefix, el);
                suffix = replaceColumnSyntax(suffix, el);
                
                // Apply **sequence** placeholder after column syntax
                text = applySequencePlaceholder(text, sequenceIndex);
                prefix = applySequencePlaceholder(prefix, sequenceIndex);
                suffix = applySequencePlaceholder(suffix, sequenceIndex);
            }
            
            // Handle boundColumn (legacy support) - only if **column** syntax wasn't used
            if(el.props.boundColumn && R && Object.prototype.hasOwnProperty.call(R, el.props.boundColumn) && !text.includes('**') && !prefix.includes('**') && !suffix.includes('**')){
            let v = R[el.props.boundColumn];
            if(el.type === 'data' && typeof v === 'number'){
                const dec = (el.props.decimals !== undefined) ? Number(el.props.decimals) : 2;
                const pct = !!el.props.asPercent;
                return prefix + fmt(v,dec,pct) + suffix;
            }
            // For barcode, return only the value (prefix/suffix are handled separately in rendering)
            if(el.type === 'barcode'){
                return String(v);
            }
            return prefix + String(v) + suffix;
        }
            
            // For text/data fields, return the processed text with prefix/suffix
            if(el.type === 'text' || el.type === 'data'){
                return prefix + text + suffix;
            }
            
            // For barcode, return only the text value (prefix/suffix will be shown separately if needed)
            if(el.type === 'barcode'){
                return text;
            }
            
        return prefix + (el.props.text || 'SAMPLE') + suffix;
    }

    function fmt(v,d,p){
        if(v===null||v===undefined||v==='') return '';
        let n=parseFloat(v);
        if(isNaN(n)) return String(v);
        if(p) n=n*100;
        n=n.toFixed(d);
        return p?n+'%':n;
    }

    // ---------- Selection / Buttons / Props ----------
    function updateBtns(){
        const has = selectedIds.length>0;
        bd.disabled = !has; bf.disabled = !has; bs.disabled = !has;
    }

    function setSelection(ids, append=false){
        if(!Array.isArray(ids)) ids = ids ? [ids] : [];
        if(append){
            ids.forEach(id=>{
                const i = selectedIds.indexOf(id);
                if(i===-1) selectedIds.push(id);
                else selectedIds.splice(i,1);
            });
        } else {
            selectedIds = ids;
        }
        render();
        updateProps();
        updateBtns();
    }

    function toggleSelection(id){
        const i = selectedIds.indexOf(id);
        if(i===-1) selectedIds.push(id);
        else selectedIds.splice(i,1);
        render();
        updateProps();
        updateBtns();
    }

    function updateProps(){
        if(selectedIds.length===0){
            // Show general design settings
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[currentDesign]) {
                pp.innerHTML = 'Select an element to edit its properties.';
                return;
            }
            const design = profile.designs[currentDesign];
            // Sequence mode is always enabled - use global count column
            
            // Get current count value
            let countValue = '';
            let countDisplay = '‚Äî';
            if(globalSequenceCountColumn && R && Object.prototype.hasOwnProperty.call(R, globalSequenceCountColumn)){
                const countRaw = R[globalSequenceCountColumn];
                const count = Math.max(0, Math.floor(Number(countRaw)));
                countValue = count;
                countDisplay = count > 0 ? String(count) : '0 (invalid)';
            }
            
            // Build column options
            let columnOptions = '<option value="">-- Select Column --</option>';
            C.forEach(col => {
                const selected = col === globalSequenceCountColumn ? 'selected' : '';
                columnOptions += `<option value="${col}" ${selected}>${col}</option>`;
            });
            
            let h = '<div style="padding:12px;">';
            h += '<h4 style="margin:0 0 12px 0;font-size:16px;font-weight:600;">Design Settings</h4>';
            h += `<div class="prop-grid"><label>Count Column</label><select id="sequence-count-column">${columnOptions}</select></div>`;
            h += `<div class="prop-grid" style="margin-top:8px;"><label>Sequence Count</label><span id="sequence-count-display" style="font-weight:600;color:#007aff;font-size:14px;">${countDisplay}</span></div>`;
            h += '</div>';
            pp.innerHTML = h;
            
            // Add event listener for column selector
            const sequenceColumnSelect = pp.querySelector('#sequence-count-column');
            const countDisplayEl = pp.querySelector('#sequence-count-display');
            
            // Function to update count display
            function updateCountDisplay(){
                if(countDisplayEl && sequenceColumnSelect){
                    let display = '‚Äî';
                    const selectedColumn = sequenceColumnSelect.value || '';
                    if(selectedColumn && R && Object.prototype.hasOwnProperty.call(R, selectedColumn)){
                        const countRaw = R[selectedColumn];
                        const count = Math.max(0, Math.floor(Number(countRaw)));
                        display = count > 0 ? String(count) : '0 (invalid)';
                    }
                    countDisplayEl.textContent = display;
                }
            }
            
            if(sequenceColumnSelect) {
                sequenceColumnSelect.addEventListener('change', function() {
                    globalSequenceCountColumn = this.value || '';
                    // Save to localStorage immediately
                    saveGlobalSequenceCountColumn();
                    updateCountDisplay();
                    render();
                });
            }
            
            // Update count display initially and store function for external updates
            updateCountDisplay();
            
            // Store update function globally so it can be called when R changes
            window.updateSequenceCountDisplay = updateCountDisplay;
            
            // Store update function globally so it can be called when R changes
            window.updateSequenceCountDisplay = updateCountDisplay;
            
            return;
        }
            
            // Check if all selected elements belong to the same group
            const groupIds = new Set();
            selectedIds.forEach(id => {
                const group = getGroupForElement(id);
                if(group) groupIds.add(group.id);
            });
            
            // If all selected elements belong to the same group, show scale control
            if(groupIds.size === 1 && selectedIds.length > 0){
                const groupId = Array.from(groupIds)[0];
                const group = groups.find(g => g.id === groupId);
                if(group && group.elementIds.length > 0){
                    // Check if all group elements are selected
                    const allGroupSelected = group.elementIds.every(id => selectedIds.includes(id));
                    if(allGroupSelected){
                        // Show scale control for the group
                        const currentBounds = getGroupBounds(group.elementIds);
                        const originalBounds = group.originalBounds || currentBounds;
                        const currentScale = originalBounds.width > 0 ? (currentBounds.width / originalBounds.width) : 1;
                        
                        pp.innerHTML = `<div style="padding:12px;">
                            <div style="margin-bottom:12px;padding:8px;background:#fff3e0;border:1px solid #ffb74d;border-radius:4px;">
                                <p style="margin:0;font-size:13px;font-weight:600;color:#e65100;">üì¶ Group Selected (${group.elementIds.length} elements)</p>
                            </div>
                            <div class="prop-grid" style="margin-bottom:12px;">
                                <label>Scale (%)</label>
                                <input type="number" id="group-scale-input" step="0.1" min="10" max="500" value="${(currentScale * 100).toFixed(1)}" style="width:100%">
                            </div>
                            <div style="font-size:12px;color:#666;margin-top:8px;">
                                <p style="margin:4px 0;">Use <strong>Ctrl+Shift+G</strong> to ungroup</p>
                                <p style="margin:4px 0;">Drag the resize handle to scale proportionally</p>
                            </div>
                        </div>`;
                        
                        // Add event listener for scale input
                        setTimeout(() => {
                            const scaleInput = document.getElementById('group-scale-input');
                            if(scaleInput){
                                let scaleTimeout = null;
                                scaleInput.addEventListener('input', (e) => {
                                    clearTimeout(scaleTimeout);
                                    scaleTimeout = setTimeout(() => {
                                        const scaleValue = parseFloat(e.target.value);
                                        if(!isNaN(scaleValue) && scaleValue > 0){
                                            scaleGroup(group, scaleValue / 100);
                                        }
                                    }, 300);
                                });
                            }
                        }, 0);
                        return;
                    }
                }
            }
            
            // Check if any selected element is in a group (but not all same group)
            const hasGroupedElement = selectedIds.some(id => getGroupForElement(id) !== undefined);
            if(hasGroupedElement){
                pp.innerHTML = `<div style="padding:12px;text-align:center;color:#666;">
                    <p style="margin-bottom:8px;">‚ö†Ô∏è Elements are grouped</p>
                    <p style="font-size:12px;margin-bottom:12px;">Use <strong>Ctrl+Shift+G</strong> to ungroup and edit properties</p>
                    <p style="font-size:12px;">Use <strong>Ctrl+G</strong> to group selected elements</p>
                </div>`;
                return;
            }
            
        if(selectedIds.length===1){
            const el = S.find(x=>x.id===selectedIds[0]);
            if(!el){ pp.innerHTML='Error: Element not found.'; return; }
            singlePropsPanel(el);
            return;
        }
        multiPropsPanel(selectedIds.map(id=>S.find(e=>e.id===id)).filter(Boolean));
    }

    // ---------- Properties Panels ----------
    function singlePropsPanel(el){
        // bound column: render search input + select
        let bindHtml = '';
        if(C && C.length){
            bindHtml = `<div style="display:flex;gap:8px;margin-bottom:8px"><input type="text" placeholder="Search columns..." data-prop="bind_search" style="flex:1"><select data-prop="props.boundColumn" style="flex:1"><option value="">-- Select Column --</option>${C.map(col=>`<option value="${col}" ${el.props.boundColumn===col?'selected':''}>${col}</option>`).join('')}</select></div>`;
        } else {
            bindHtml = `<select data-prop="props.boundColumn"><option value="">-- No columns --</option></select>`;
        }

            let h = `<div class="prop-grid"><label>X</label><input type="number" step="0.01" data-prop="x" value="${(Number(el.x)||0).toFixed(2)}"><label>Y</label><input type="number" step="0.01" data-prop="y" value="${(Number(el.y)||0).toFixed(2)}"></div>`;
            h += `<div class="prop-grid"><label>Width</label><input type="number" step="0.01" data-prop="width" value="${(Number(el.width)||0).toFixed(2)}"><label>Height</label><input type="number" step="0.01" data-prop="height" value="${(Number(el.height)||0).toFixed(2)}"></div><hr>`;

        if(el.type==='text') h += `<label>Text</label><textarea data-prop="props.text">${escapeHtml(el.props.text||'')}</textarea>`;

            if(el.type==='data' || el.type==='qr' || el.type==='barcode' || el.type==='image'){
            h += `<label>Bound Column</label>${bindHtml}`;
        }

        if(el.type==='data'){
                h += `<label>Prefix</label><textarea data-prop="props.prefix" rows="2">${escapeHtml(el.props.prefix||'')}</textarea>`;
                h += `<label>Suffix</label><textarea data-prop="props.suffix" rows="2">${escapeHtml(el.props.suffix||'')}</textarea>`;
            h += `<hr><div class="prop-grid"><label>Decimals</label><input type="number" step="1" data-prop="props.decimals" value="${el.props.decimals!==undefined?el.props.decimals:2}" min="0" max="10"><label>As Percent</label><input type="checkbox" data-prop="props.asPercent" ${el.props.asPercent?'checked':''}></div>`;
        }

        if(el.type==='qr' || el.type==='barcode'){
            h += `<label>Fallback Text</label><input type="text" data-prop="props.text" value="${escapeHtml(el.props.text||'')}">`;
        }

        if(el.type==='barcode'){
            h += `<label>Prefix</label><textarea data-prop="props.prefix" rows="2">${escapeHtml(el.props.prefix||'')}</textarea>`;
            h += `<label>Suffix</label><textarea data-prop="props.suffix" rows="2">${escapeHtml(el.props.suffix||'')}</textarea>`;
            h += `<label>Format</label><select data-prop="props.format"><option value="CODE128" ${el.props.format==='CODE128'?'selected':''}>CODE128</option><option value="CODE39" ${el.props.format==='CODE39'?'selected':''}>CODE39</option><option value="EAN13" ${el.props.format==='EAN13'?'selected':''}>EAN13</option><option value="UPC" ${el.props.format==='UPC'?'selected':''}>UPC</option></select><label>Show Text</label><input type="checkbox" data-prop="props.displayValue" ${el.props.displayValue!==false?'checked':''}>`;
        }

        if(el.type==='line'){
                h += `<label>Thickness (px)</label><input type="number" step="1" data-prop="props.thickness" value="${el.props.thickness!==undefined?el.props.thickness:2}" min="0">`;
                h += `<hr><div class="prop-grid"><label>Rotation¬∞</label><input type="number" step="1" data-prop="props.rotation" value="${el.props.rotation||0}"><label></label></div>`;
        }

        if(el.type==='box'){
            h += `<label>Border (px)</label><input type="number" step="1" data-prop="props.thickness" value="${el.props.thickness!==undefined?el.props.thickness:2}" min="0"><label>Fill Color</label><input type="color" data-prop="props.fillColor" value="${el.props.fillColor||'#ffffff'}">`;
                // Add border radius control for box elements
                h += `<hr><div style="margin-top:8px"><label style="font-size:12px;display:block;margin-bottom:6px">Border Radius (px):</label><div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;max-width:200px"><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üñ Top Left</label><input type="number" data-prop="props.borderRadiusTopLeft" value="${Number(el.props.borderRadiusTopLeft||0)}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üó Top Right</label><input type="number" data-prop="props.borderRadiusTopRight" value="${Number(el.props.borderRadiusTopRight||0)}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üô Bottom Left</label><input type="number" data-prop="props.borderRadiusBottomLeft" value="${Number(el.props.borderRadiusBottomLeft||0)}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üò Bottom Right</label><input type="number" data-prop="props.borderRadiusBottomRight" value="${Number(el.props.borderRadiusBottomRight||0)}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div></div></div>`;
        }

            if(el.type==='image'){
                h += `<hr><label>Object Fit</label><select data-prop="props.objectFit"><option value="contain" ${(el.props.objectFit||'contain')==='contain'?'selected':''}>Contain</option><option value="cover" ${el.props.objectFit==='cover'?'selected':''}>Cover</option><option value="fill" ${el.props.objectFit==='fill'?'selected':''}>Fill</option><option value="none" ${el.props.objectFit==='none'?'selected':''}>None</option><option value="scale-down" ${el.props.objectFit==='scale-down'?'selected':''}>Scale Down</option></select>`;
            }

            if(el.type==='text' || el.type==='data'){
                const currentFontFamily = el.props.fontFamily || 'Arial, sans-serif';
                h += `<hr><div class="prop-grid"><label>Font Size</label><input type="number" step="1" data-prop="props.fontSize" value="${el.props.fontSize||16}" min="6" max="200"><label>Font Family</label><div style="display:flex;gap:4px;align-items:center"><select data-prop="props.fontFamily" id="font-family-select-${el.id}" style="flex:1">${generateFontOptions(currentFontFamily)}</select><button type="button" id="font-favorite-btn-${el.id}" style="padding:4px 8px;font-size:16px;background:transparent;border:1px solid #ccc;border-radius:4px;cursor:pointer;flex-shrink:0" title="${fontFavorites.includes(currentFontFamily) ? 'Remove from favorites' : 'Add to favorites'}">${fontFavorites.includes(currentFontFamily) ? '‚≠ê' : '‚òÜ'}</button></div></div>`;
                h += `<div class="prop-grid"><label>Weight</label><select data-prop="props.fontWeight" id="font-weight-select-${el.id}">${generateWeightOptions(currentFontFamily, el.props.fontWeight)}</select><label>Line Height</label><input type="number" step="0.1" data-prop="props.lineHeight" value="${el.props.lineHeight!==undefined?el.props.lineHeight:1.2}" min="0.5" max="3"></div>`;
                h += `<div class="prop-grid"><label>H. Align</label><select data-prop="props.textAlign"><option value="left" ${el.props.textAlign==='left'?'selected':''}>Left</option><option value="center" ${el.props.textAlign==='center'?'selected':''}>Center</option><option value="right" ${el.props.textAlign==='right'?'selected':''}>Right</option></select><label>V. Align</label><select data-prop="props.valign"><option value="top" ${el.props.valign==='top'?'selected':''}>Top</option><option value="middle" ${el.props.valign==='middle'?'selected':''}>Middle</option><option value="bottom" ${el.props.valign==='bottom'?'selected':''}>Bottom</option></select></div>`;
                h += `<div class="prop-grid"><label>Overflow</label><select data-prop="props.textOverflow"><option value="clip" ${(el.props.textOverflow||'clip')==='clip'?'selected':''}>Clip (default)</option><option value="auto-scale" ${el.props.textOverflow==='auto-scale'?'selected':''}>Auto-scale to fit</option><option value="squeeze" ${el.props.textOverflow==='squeeze'?'selected':''}>Horizontal squeeze</option></select><label>Rotation¬∞</label><input type="number" step="1" data-prop="props.rotation" value="${el.props.rotation||0}"></div>`;
                h += `<hr><div class="prop-grid"><label>Padding Top</label><input type="number" step="0.01" data-prop="props.paddingTop" value="${Number(el.props.paddingTop||0).toFixed(2)}" min="0"><label>Padding Right</label><input type="number" step="0.01" data-prop="props.paddingRight" value="${Number(el.props.paddingRight||0).toFixed(2)}" min="0"></div>`;
                h += `<div class="prop-grid"><label>Padding Bottom</label><input type="number" step="0.01" data-prop="props.paddingBottom" value="${Number(el.props.paddingBottom||0).toFixed(2)}" min="0"><label>Padding Left</label><input type="number" step="0.01" data-prop="props.paddingLeft" value="${Number(el.props.paddingLeft||0).toFixed(2)}" min="0"></div>`;
            }

            // border
        h += `<hr><div class="prop-grid"><label>Show Border</label><input type="checkbox" data-prop="props.showBorder" ${el.props.showBorder?'checked':''}><label>Border Color</label><input type="color" data-prop="props.borderColor" value="${el.props.borderColor||'#000000'}"></div>`;
            h += `<div class="prop-grid"><label>Border Width</label><input type="number" data-prop="props.borderWidth" value="${el.props.borderWidth||1}" min="0"><label></label></div>`;
            if(el.props.showBorder){
                h += `<div class="prop-grid" style="margin-top:8px"><label style="font-size:12px">Border Sides:</label><div style="display:grid;grid-template-columns:1fr 1fr;gap:4px"><label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:4px"><input type="checkbox" data-prop="props.borderTop" ${el.props.borderTop!==false?'checked':''}>Top</label><label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:4px"><input type="checkbox" data-prop="props.borderRight" ${el.props.borderRight!==false?'checked':''}>Right</label><label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:4px"><input type="checkbox" data-prop="props.borderBottom" ${el.props.borderBottom!==false?'checked':''}>Bottom</label><label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:4px"><input type="checkbox" data-prop="props.borderLeft" ${el.props.borderLeft!==false?'checked':''}>Left</label></div></div>`;
                h += `<div style="margin-top:8px"><label style="font-size:12px;display:block;margin-bottom:6px">Border Radius (px):</label><div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;max-width:200px"><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üñ Top Left</label><input type="number" data-prop="props.borderRadiusTopLeft" value="${Number(el.props.borderRadiusTopLeft||0)}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üó Top Right</label><input type="number" data-prop="props.borderRadiusTopRight" value="${Number(el.props.borderRadiusTopRight||0)}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üô Bottom Left</label><input type="number" data-prop="props.borderRadiusBottomLeft" value="${Number(el.props.borderRadiusBottomLeft||0)}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üò Bottom Right</label><input type="number" data-prop="props.borderRadiusBottomRight" value="${Number(el.props.borderRadiusBottomRight||0)}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div></div></div>`;
            }
        if(el.type!=='box') h += `<hr><label>Color</label><input type="color" data-prop="props.color" value="${el.props.color||'#000000'}">`;
        h += `<hr><button id="btn-delete">Delete Element</button>`;
        pp.innerHTML = h;
            
            // Add listener to update weight options when font family changes
            if(el.type === 'text' || el.type === 'data'){
                const fontFamilySelect = pp.querySelector(`#font-family-select-${el.id}`);
                const weightSelect = pp.querySelector(`#font-weight-select-${el.id}`);
                const favoriteBtn = pp.querySelector(`#font-favorite-btn-${el.id}`);
                
                if(fontFamilySelect && weightSelect){
                    fontFamilySelect.addEventListener('change', function(){
                        const newFontFamily = this.value;
                        const currentWeight = el.props.fontWeight || 'normal';
                        weightSelect.innerHTML = generateWeightOptions(newFontFamily, currentWeight);
                        // Update favorite button
                        if(favoriteBtn) {
                            favoriteBtn.innerHTML = fontFavorites.includes(newFontFamily) ? '‚≠ê' : '‚òÜ';
                            favoriteBtn.title = fontFavorites.includes(newFontFamily) ? 'Remove from favorites' : 'Add to favorites';
                        }
                        // Trigger change event to update element
                        this.dispatchEvent(new Event('input', { bubbles: true }));
                    });
                    
                    // Add keyboard navigation (arrow keys) with live preview
                    let originalFontFamily = el.props.fontFamily || 'Arial, sans-serif';
                    fontFamilySelect.addEventListener('focus', function(){
                        originalFontFamily = el.props.fontFamily || 'Arial, sans-serif';
                    });
                    
                    fontFamilySelect.addEventListener('keydown', function(e){
                        if(e.key === 'ArrowUp' || e.key === 'ArrowDown'){
                            e.preventDefault();
                            const options = Array.from(this.options);
                            const currentIndex = this.selectedIndex;
                            let newIndex;
                            if(e.key === 'ArrowUp'){
                                newIndex = currentIndex > 0 ? currentIndex - 1 : options.length - 1;
                            } else {
                                newIndex = currentIndex < options.length - 1 ? currentIndex + 1 : 0;
                            }
                            this.selectedIndex = newIndex;
                            const newFontFamily = this.options[newIndex].value;
                            
                            // Update element temporarily for live preview
                            el.props.fontFamily = newFontFamily;
                            const currentWeight = el.props.fontWeight || 'normal';
                            weightSelect.innerHTML = generateWeightOptions(newFontFamily, currentWeight);
                            
                            // Update favorite button
                            if(favoriteBtn) {
                                favoriteBtn.innerHTML = fontFavorites.includes(newFontFamily) ? '‚≠ê' : '‚òÜ';
                                favoriteBtn.title = fontFavorites.includes(newFontFamily) ? 'Remove from favorites' : 'Add to favorites';
                            }
                            
                            // Render to show the change
                            render();
                        } else if(e.key === 'Escape'){
                            // Restore original font on Escape
                            el.props.fontFamily = originalFontFamily;
                            this.value = originalFontFamily;
                            const currentWeight = el.props.fontWeight || 'normal';
                            weightSelect.innerHTML = generateWeightOptions(originalFontFamily, currentWeight);
                            if(favoriteBtn) {
                                favoriteBtn.innerHTML = fontFavorites.includes(originalFontFamily) ? '‚≠ê' : '‚òÜ';
                                favoriteBtn.title = fontFavorites.includes(originalFontFamily) ? 'Remove from favorites' : 'Add to favorites';
                            }
                            render();
                        }
                    });
                    
                    // Save on blur (when user leaves the select)
                    fontFamilySelect.addEventListener('blur', function(){
                        // Trigger change event to save
                        this.dispatchEvent(new Event('change', { bubbles: true }));
                    });
                }
                
                // Add favorite button listener
                if(favoriteBtn){
                    favoriteBtn.addEventListener('click', function(e){
                        e.preventDefault();
                        const currentFont = fontFamilySelect.value;
                        toggleFontFavorite(currentFont);
                        // Update button
                        this.innerHTML = fontFavorites.includes(currentFont) ? '‚≠ê' : '‚òÜ';
                        this.title = fontFavorites.includes(currentFont) ? 'Remove from favorites' : 'Add to favorites';
                        // Regenerate options to reflect favorites
                        const selectedValue = fontFamilySelect.value;
                        fontFamilySelect.innerHTML = generateFontOptions(selectedValue);
                        fontFamilySelect.value = selectedValue;
                    });
                }
            }
    }

    function multiPropsPanel(elems){
        function common(propPath){
            const parts = propPath.split('.');
            let val = undefined;
            for(const el of elems){
                let cur = el;
                for(const p of parts){
                    if(cur && Object.prototype.hasOwnProperty.call(cur,p)) cur = cur[p]; else { cur = undefined; break; }
                }
                if(val === undefined) val = cur;
                else if(String(val) !== String(cur)) return '';
            }
            return val === undefined ? '' : val;
        }

            const commonFontFamily = common('props.fontFamily') || 'Arial, sans-serif';
            const commonWeight = common('props.fontWeight') || 'normal';
        let h = `<div style="font-weight:600;margin-bottom:6px">${elems.length} elements selected</div>`;
            h += `<div class="prop-grid"><label>X</label><input type="number" step="0.01" data-prop="multi.x" value="${common('x')}"><label>Y</label><input type="number" step="0.01" data-prop="multi.y" value="${common('y')}"></div>`;
            h += `<div class="prop-grid"><label>Width</label><input type="number" step="0.01" data-prop="multi.width" value="${common('width')}"><label>Height</label><input type="number" step="0.01" data-prop="multi.height" value="${common('height')}"></div><hr>`;
                h += `<div class="prop-grid"><label>Font Size</label><input type="number" step="0.1" data-prop="multi.props.fontSize" value="${common('props.fontSize')}" min="6"><label>Font Family</label><div style="display:flex;gap:4px;align-items:center"><select data-prop="multi.props.fontFamily" id="multi-font-family-select" style="flex:1">${generateFontOptions(commonFontFamily)}</select><button type="button" id="multi-font-favorite-btn" style="padding:4px 8px;font-size:16px;background:transparent;border:1px solid #ccc;border-radius:4px;cursor:pointer;flex-shrink:0" title="${fontFavorites.includes(commonFontFamily) ? 'Remove from favorites' : 'Add to favorites'}">${fontFavorites.includes(commonFontFamily) ? '‚≠ê' : '‚òÜ'}</button></div></div>`;
            h += `<div class="prop-grid"><label>Font Weight</label><select data-prop="multi.props.fontWeight" id="multi-font-weight-select">${generateWeightOptions(commonFontFamily, commonWeight)}</select><label>Line Height</label><input type="number" step="0.1" data-prop="multi.props.lineHeight" value="${common('props.lineHeight')}" min="0.5" max="3"></div>`;
            h += `<div class="prop-grid"><label>H. Align</label><select data-prop="multi.props.textAlign"><option value="">‚Äî</option><option value="left" ${common('props.textAlign')==='left'?'selected':''}>Left</option><option value="center" ${common('props.textAlign')==='center'?'selected':''}>Center</option><option value="right" ${common('props.textAlign')==='right'?'selected':''}>Right</option></select><label>V. Align</label><select data-prop="multi.props.valign"><option value="">‚Äî</option><option value="top" ${common('props.valign')==='top'?'selected':''}>Top</option><option value="middle" ${common('props.valign')==='middle'?'selected':''}>Middle</option><option value="bottom" ${common('props.valign')==='bottom'?'selected':''}>Bottom</option></select></div>`;
            const hasTextOrData = elems.some(el => el.type === 'text' || el.type === 'data');
            if(hasTextOrData){
                h += `<div class="prop-grid"><label>Overflow</label><select data-prop="multi.props.textOverflow"><option value="">‚Äî</option><option value="clip" ${(common('props.textOverflow')||'clip')==='clip'?'selected':''}>Clip (default)</option><option value="auto-scale" ${common('props.textOverflow')==='auto-scale'?'selected':''}>Auto-scale to fit</option><option value="squeeze" ${common('props.textOverflow')==='squeeze'?'selected':''}>Horizontal squeeze</option></select><label></label></div>`;
            }
            // Show decimals only if at least one element is of type 'data'
            const hasDataElement = elems.some(el => el.type === 'data');
            if(hasDataElement){
                    h += `<hr><div class="prop-grid"><label>Decimals</label><input type="number" step="0.1" data-prop="multi.props.decimals" value="${common('props.decimals')!==''?common('props.decimals'):2}" min="0" max="10"><label>As Percent</label><input type="checkbox" data-prop="multi.props.asPercent" ${common('props.asPercent')?'checked':''}></div>`;
                }
                // Show box controls only if at least one element is of type 'box'
                const hasBoxElement = elems.some(el => el.type === 'box');
                if(hasBoxElement){
                    h += `<hr><div class="prop-grid"><label>Border (px)</label><input type="number" step="1" data-prop="multi.props.thickness" value="${common('props.thickness')!==''?common('props.thickness'):2}" min="0"><label>Border Color</label><input type="color" data-prop="multi.props.color" value="${common('props.color')||'#000000'}"></div>`;
                    h += `<div class="prop-grid"><label>Fill Color</label><input type="color" data-prop="multi.props.fillColor" value="${common('props.fillColor')||'#ffffff'}"><label></label></div>`;
            }
            h += `<div class="prop-grid"><label>Padding Top</label><input type="number" step="0.01" data-prop="multi.props.paddingTop" value="${common('props.paddingTop')}" min="0"><label>Padding Right</label><input type="number" step="0.01" data-prop="multi.props.paddingRight" value="${common('props.paddingRight')}" min="0"></div>`;
            h += `<div class="prop-grid"><label>Padding Bottom</label><input type="number" step="0.01" data-prop="multi.props.paddingBottom" value="${common('props.paddingBottom')}" min="0"><label>Padding Left</label><input type="number" step="0.01" data-prop="multi.props.paddingLeft" value="${common('props.paddingLeft')}" min="0"></div>`;
                h += `<hr><div class="prop-grid"><label>Rotation¬∞</label><input type="number" step="0.1" data-prop="multi.props.rotation" value="${common('props.rotation')}"><label>Show Border</label><input type="checkbox" data-prop="multi.props.showBorder" ${common('props.showBorder')?'checked':''}></div>`;
            h += `<div class="prop-grid"><label>Border Color</label><input type="color" data-prop="multi.props.borderColor" value="${common('props.borderColor')||'#000000'}"><label>Border Width</label><input type="number" step="1" data-prop="multi.props.borderWidth" value="${common('props.borderWidth')}" min="0"></div>`;
            if(common('props.showBorder')){
                h += `<div class="prop-grid" style="margin-top:8px"><label style="font-size:12px">Border Sides:</label><div style="display:grid;grid-template-columns:1fr 1fr;gap:4px"><label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:4px"><input type="checkbox" data-prop="multi.props.borderTop" ${common('props.borderTop')!==false?'checked':''}>Top</label><label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:4px"><input type="checkbox" data-prop="multi.props.borderRight" ${common('props.borderRight')!==false?'checked':''}>Right</label><label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:4px"><input type="checkbox" data-prop="multi.props.borderBottom" ${common('props.borderBottom')!==false?'checked':''}>Bottom</label><label style="font-size:12px;font-weight:normal;display:flex;align-items:center;gap:4px"><input type="checkbox" data-prop="multi.props.borderLeft" ${common('props.borderLeft')!==false?'checked':''}>Left</label></div></div>`;
                h += `<div style="margin-top:8px"><label style="font-size:12px;display:block;margin-bottom:6px">Border Radius (px):</label><div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;max-width:200px"><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üñ Top Left</label><input type="number" data-prop="multi.props.borderRadiusTopLeft" value="${common('props.borderRadiusTopLeft')||0}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üó Top Right</label><input type="number" data-prop="multi.props.borderRadiusTopRight" value="${common('props.borderRadiusTopRight')||0}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üô Bottom Left</label><input type="number" data-prop="multi.props.borderRadiusBottomLeft" value="${common('props.borderRadiusBottomLeft')||0}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div><div style="display:flex;flex-direction:column;gap:2px"><label style="font-size:11px;font-weight:normal;text-align:center">‚Üò Bottom Right</label><input type="number" data-prop="multi.props.borderRadiusBottomRight" value="${common('props.borderRadiusBottomRight')||0}" min="0" step="0.1" style="font-size:12px;padding:4px;text-align:center"></div></div></div>`;
            }
            // Show general color only if not all elements are boxes (boxes have their own color controls)
            const allBoxes = elems.every(el => el.type === 'box');
            if(!allBoxes){
        h += `<div class="prop-grid"><label>Color</label><input type="color" data-prop="multi.props.color" value="${common('props.color')||'#000000'}"><label></label></div>`;
            }
        h += `<hr><button id="btn-delete">Delete Selected</button>`;
        pp.innerHTML = h;
            
            // Add listener to update weight options when font family changes (multi-select)
            const multiFontFamilySelect = pp.querySelector('#multi-font-family-select');
            const multiWeightSelect = pp.querySelector('#multi-font-weight-select');
            const multiFavoriteBtn = pp.querySelector('#multi-font-favorite-btn');
            
            if(multiFontFamilySelect && multiWeightSelect){
                multiFontFamilySelect.addEventListener('change', function(){
                    const newFontFamily = this.value;
                    const currentWeight = commonWeight;
                    multiWeightSelect.innerHTML = generateWeightOptions(newFontFamily, currentWeight);
                    // Update favorite button
                    if(multiFavoriteBtn) {
                        multiFavoriteBtn.innerHTML = fontFavorites.includes(newFontFamily) ? '‚≠ê' : '‚òÜ';
                        multiFavoriteBtn.title = fontFavorites.includes(newFontFamily) ? 'Remove from favorites' : 'Add to favorites';
                    }
                    // Trigger change event to update elements
                    this.dispatchEvent(new Event('input', { bubbles: true }));
                });
                
                // Add keyboard navigation (arrow keys) with live preview
                let originalFontFamily = commonFontFamily;
                multiFontFamilySelect.addEventListener('focus', function(){
                    originalFontFamily = commonFontFamily;
                });
                
                multiFontFamilySelect.addEventListener('keydown', function(e){
                    if(e.key === 'ArrowUp' || e.key === 'ArrowDown'){
                        e.preventDefault();
                        e.stopPropagation(); // Prevent event from bubbling to global listener
                        const options = Array.from(this.options);
                        const currentIndex = this.selectedIndex;
                        let newIndex;
                        if(e.key === 'ArrowUp'){
                            newIndex = currentIndex > 0 ? currentIndex - 1 : options.length - 1;
                        } else {
                            newIndex = currentIndex < options.length - 1 ? currentIndex + 1 : 0;
                        }
                        this.selectedIndex = newIndex;
                        const newFontFamily = this.options[newIndex].value;
                        
                        // Update all selected elements temporarily for live preview
                        selectedIds.forEach(id => {
                            const elem = S.find(s => s.id === id);
                            if(elem && (elem.type === 'text' || elem.type === 'data')){
                                elem.props.fontFamily = newFontFamily;
                            }
                        });
                        
                        const currentWeight = commonWeight;
                        multiWeightSelect.innerHTML = generateWeightOptions(newFontFamily, currentWeight);
                        
                        // Update favorite button
                        if(multiFavoriteBtn) {
                            multiFavoriteBtn.innerHTML = fontFavorites.includes(newFontFamily) ? '‚≠ê' : '‚òÜ';
                            multiFavoriteBtn.title = fontFavorites.includes(newFontFamily) ? 'Remove from favorites' : 'Add to favorites';
                        }
                        
                        // Render to show the change
                        render();
                    } else if(e.key === 'Escape'){
                        e.preventDefault();
                        e.stopPropagation();
                        // Restore original font on Escape
                        selectedIds.forEach(id => {
                            const elem = S.find(s => s.id === id);
                            if(elem && (elem.type === 'text' || elem.type === 'data')){
                                elem.props.fontFamily = originalFontFamily;
                            }
                        });
                        this.value = originalFontFamily;
                        const currentWeight = commonWeight;
                        multiWeightSelect.innerHTML = generateWeightOptions(originalFontFamily, currentWeight);
                        if(multiFavoriteBtn) {
                            multiFavoriteBtn.innerHTML = fontFavorites.includes(originalFontFamily) ? '‚≠ê' : '‚òÜ';
                            multiFavoriteBtn.title = fontFavorites.includes(originalFontFamily) ? 'Remove from favorites' : 'Add to favorites';
                        }
                        render();
                    }
                });
                
                // Save on blur (when user leaves the select)
                multiFontFamilySelect.addEventListener('blur', function(){
                    // Trigger change event to save
                    this.dispatchEvent(new Event('change', { bubbles: true }));
                });
            }
            
            // Add spinner handlers for x, y, width, height when input is empty (indeterminate state)
            const positionInputs = ['multi.x', 'multi.y', 'multi.width', 'multi.height'];
            positionInputs.forEach(propName => {
                const input = pp.querySelector(`input[data-prop="${propName}"]`);
                if(input){
                    // Initialize previous value
                    input.dataset.previousValue = input.value || '';
                    let previousValue = input.value;
                    let isSpinnerClick = false;
                    
                    // Detect spinner clicks (mouse clicks on spinner buttons)
                    input.addEventListener('mousedown', function(e){
                        // Check if click is on spinner (right side of input)
                        const rect = this.getBoundingClientRect();
                        const clickX = e.clientX;
                        const clickY = e.clientY;
                        const isOnSpinner = clickX > rect.right - 20; // Spinner is usually ~20px wide
                        
                        if(isOnSpinner && (this.value === '' || this.value === null || isNaN(this.value))){
                            isSpinnerClick = true;
                            // Determine if up or down based on Y position (vertical position in spinner)
                            const relativeY = clickY - rect.top;
                            const spinnerHeight = rect.height;
                            const isUp = relativeY < spinnerHeight / 2; // Top half = up, bottom half = down
                            
                            e.preventDefault();
                            e.stopPropagation();
                            
                            // Get the property name (x, y, width, or height)
                            const propKey = propName.split('.')[1];
                            
                            // Get all selected elements and their current values
                            const elements = selectedIds.map(id => S.find(e => e.id === id)).filter(Boolean);
                            if(elements.length === 0) return;
                            
                            pushBeforeChange();
                            
                            // Convert 1 pixel to cm (1 pixel = 1/37.795276 cm)
                            const onePixelInCm = 1 / PIXELS_PER_CM;
                            const delta = isUp ? onePixelInCm : -onePixelInCm;
                            
                            // Increment or decrement all values by 1 pixel
                            elements.forEach(el => {
                                const currentVal = el[propKey] || 0;
                                const newVal = currentVal + delta;
                                el[propKey] = snapToPixel(newVal);
                            });
                            
                            render();
                            updateProps();
                            saveCurrentDesign();
                            
                            // Prevent default spinner behavior
                            return false;
                        }
                    });
                    
                    // Also handle wheel events on the input (alternative way to use spinner)
                    input.addEventListener('wheel', function(e){
                        if(this.value === '' || this.value === null || isNaN(this.value)){
                            e.preventDefault();
                            e.stopPropagation();
                            
                            const propKey = propName.split('.')[1];
                            const elements = selectedIds.map(id => S.find(e => e.id === id)).filter(Boolean);
                            if(elements.length === 0) return;
                            
                            pushBeforeChange();
                            
                            // Convert 1 pixel to cm (1 pixel = 1/37.795276 cm)
                            const onePixelInCm = 1 / PIXELS_PER_CM;
                            const delta = e.deltaY < 0 ? onePixelInCm : -onePixelInCm; // Scroll up = increment, scroll down = decrement
                            
                            elements.forEach(el => {
                                const currentVal = el[propKey] || 0;
                                const newVal = currentVal + delta;
                                el[propKey] = snapToPixel(newVal);
                            });
                            
                            render();
                            updateProps();
                            saveCurrentDesign();
                        }
                    }, { passive: false });
                    
                    // Track value changes to detect spinner usage via keyboard
                    input.addEventListener('input', function(e){
                        if(isSpinnerClick){
                            isSpinnerClick = false;
                            return;
                        }
                        
                        // If input was empty and now has a value, it might be from spinner
                        if((previousValue === '' || previousValue === null || isNaN(previousValue)) && 
                           this.value !== '' && !isNaN(this.value)){
                            // Check if this looks like a spinner increment (step value)
                            const newVal = Number(this.value);
                            const propKey = propName.split('.')[1];
                            const elements = selectedIds.map(id => S.find(e => e.id === id)).filter(Boolean);
                            
                            if(elements.length > 0){
                                // Get the first element's current value
                                const firstVal = elements[0][propKey] || 0;
                                const step = Number(input.step) || 0.01;
                                
                                // If the new value is close to firstVal + step, it's likely a spinner up
                                // If the new value is close to firstVal - step, it's likely a spinner down
                                const diff = Math.abs(newVal - firstVal);
                                const onePixelInCm = 1 / PIXELS_PER_CM;
                                if(diff <= step * 2){ // Allow some tolerance
                                    e.preventDefault();
                                    e.stopPropagation();
                                    
                                    pushBeforeChange();
                                    
                                    // Convert 1 pixel to cm (1 pixel = 1/37.795276 cm)
                                    const delta = newVal > firstVal ? onePixelInCm : -onePixelInCm;
                                    elements.forEach(el => {
                                        const currentVal = el[propKey] || 0;
                                        const newVal = currentVal + delta;
                                        el[propKey] = snapToPixel(newVal);
                                    });
                                    
                                    render();
                                    updateProps();
                                    saveCurrentDesign();
                                    return false;
                                }
                            }
                        }
                        previousValue = this.value;
                    });
                }
            });
            
            // Add favorite button listener
            if(multiFavoriteBtn){
                multiFavoriteBtn.addEventListener('click', function(e){
                    e.preventDefault();
                    const currentFont = multiFontFamilySelect.value;
                    toggleFontFavorite(currentFont);
                    // Update button
                    this.innerHTML = fontFavorites.includes(currentFont) ? '‚≠ê' : '‚òÜ';
                    this.title = fontFavorites.includes(currentFont) ? 'Remove from favorites' : 'Add to favorites';
                    // Regenerate options to reflect favorites
                    const selectedValue = multiFontFamilySelect.value;
                    multiFontFamilySelect.innerHTML = generateFontOptions(selectedValue);
                    multiFontFamilySelect.value = selectedValue;
                });
            }
    }

    function escapeHtml(str){ if(str===null||str===undefined) return ''; return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }

        // ---------- Font weights mapping ----------
        function getFontWeights(fontFamily){
            // Only include weights that are actually supported by the font
            // Most system fonts only support normal (400) and bold (700)
            const fontWeights = {
                'Arial, sans-serif': [400, 700, 'normal', 'bold'],
                "'Courier New', monospace": [400, 700, 'normal', 'bold'],
                'Consolas, monospace': [400, 700, 'normal', 'bold'],
                'Georgia, serif': [400, 700, 'normal', 'bold'],
                "'Times New Roman', serif": [400, 700, 'normal', 'bold'],
                'Verdana, sans-serif': [400, 700, 'normal', 'bold'],
                "'Trebuchet MS', sans-serif": [400, 700, 'normal', 'bold'],
                'Impact, sans-serif': [400, 'normal'], // Impact only has one weight
                "'Comic Sans MS', cursive": [400, 700, 'normal', 'bold'],
                    "'Montserrat', sans-serif": [100, 200, 300, 400, 500, 600, 700, 800, 900, 'normal', 'bold'], // Google Font: Montserrat
                "'Winky Rough', sans-serif": [300, 400, 500, 600, 700, 800, 900, 'normal', 'bold'], // Custom font with multiple weights
                "'Oswald', sans-serif": [200, 300, 400, 500, 600, 700, 'normal', 'bold'], // Google Font: Oswald
                "'Roboto Condensed', sans-serif": [300, 400, 700, 'normal', 'bold'], // Google Font: Roboto Condensed
                "'Sofia Sans Extra Condensed', sans-serif": [100, 200, 300, 400, 500, 600, 700, 800, 900, 'normal', 'bold'] // Google Font: Sofia Sans Extra Condensed
            };
            return fontWeights[fontFamily] || [400, 700, 'normal', 'bold'];
        }

        function getWeightLabel(weight){
            const labels = {
                100: 'Thin (100)',
                200: 'Extra Light (200)',
                300: 'Light (300)',
                400: 'Normal (400)',
                500: 'Medium (500)',
                600: 'Semi Bold (600)',
                700: 'Bold (700)',
                800: 'Extra Bold (800)',
                900: 'Black (900)',
                'normal': 'Normal',
                'bold': 'Bold'
            };
            return labels[weight] || String(weight);
        }

        function generateWeightOptions(fontFamily, currentWeight){
            const weights = getFontWeights(fontFamily);
            return weights.map(w => {
                const value = typeof w === 'number' ? w : w;
                // Check if current weight matches: exact match, or numeric equivalents
                let isSelected = false;
                if(currentWeight === w){
                    isSelected = true;
                } else if(w === 'normal' && (currentWeight === 400 || currentWeight === 'normal')){
                    isSelected = true;
                } else if(w === 'bold' && (currentWeight === 700 || currentWeight === 'bold')){
                    isSelected = true;
                } else if(typeof w === 'number' && typeof currentWeight === 'number' && w === currentWeight){
                    isSelected = true;
                } else if(typeof w === 'number' && currentWeight === String(w)){
                    isSelected = true;
                }
                return `<option value="${value}" ${isSelected ? 'selected' : ''}>${getWeightLabel(w)}</option>`;
            }).join('');
        }

        // ---------- Improved column search ----------
        function searchColumns(query, columns){
            if(!query || !query.trim()) return columns.map(col => ({ col, score: 0 }));
            const q = query.toLowerCase().trim();
            const queryWords = q.split(/\s+/).filter(w => w.length > 0);
            
            return columns.map(col => {
                const colLower = col.toLowerCase();
                let score = 0;
                
                // Exact match (highest priority)
                if(colLower === q){
                    score = 1000;
                }
                // Starts with query
                else if(colLower.startsWith(q)){
                    score = 500;
                }
                // Contains query as whole substring
                else if(colLower.includes(q)){
                    score = 300;
                }
                // All query words present in order (multi-word search)
                else if(queryWords.length > 1){
                    const allWordsPresent = queryWords.every(word => colLower.includes(word));
                    if(allWordsPresent){
                        // Check if words appear in order (bonus points)
                        let lastIndex = -1;
                        let inOrder = true;
                        for(const word of queryWords){
                            const idx = colLower.indexOf(word, lastIndex + 1);
                            if(idx === -1){
                                inOrder = false;
                                break;
                            }
                            lastIndex = idx;
                        }
                        score = inOrder ? 250 : 200;
                    }
                }
                // Single word: check if it matches word boundaries or parts
                else if(queryWords.length === 1){
                    const word = queryWords[0];
                    // Check word boundary matches (e.g., "name" matches "full_name" or "name_field")
                    const wordBoundaryRegex = new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i');
                    if(wordBoundaryRegex.test(col)){
                        score = 400;
                    }
                    // Check if word appears as part of another word
                    else if(colLower.includes(word)){
                        score = 150;
                    }
                }
                
                // Fuzzy matching: check if all characters of query appear in order in column name
                if(score === 0){
                    let queryIdx = 0;
                    for(let i = 0; i < colLower.length && queryIdx < q.length; i++){
                        if(colLower[i] === q[queryIdx]){
                            queryIdx++;
                        }
                    }
                    if(queryIdx === q.length){
                        score = 50; // All characters found in order
                    }
                }
                
                return { col, score };
            })
            .filter(result => result.score > 0)
            .sort((a, b) => {
                // Sort by score (descending), then alphabetically for same score
                if(b.score !== a.score) return b.score - a.score;
                return a.col.localeCompare(b.col);
            });
        }

    // ---------- Element operations (multi-aware) ----------
    function pushBeforeChange(){ pushHistorySnapshot(); }

    function add(type){
        pushBeforeChange();
        const mz = S.length>0 ? Math.max(...S.map(e=>e.zIndex||0)) : 0;
        const n = {
            id: `el_${Date.now()}`,
            type,
            x:.5,y:.5,width:1.5,height:.5,zIndex:mz+1,
            props:{
                text:'Sample Text',fontSize:16,fontWeight:'normal',fontFamily:'Arial, sans-serif',
                textAlign:'left',valign:'top',color:'#000000',boundColumn:'',prefix:'',suffix:'',
                rotation:0,showBorder:false,borderColor:'#000',borderWidth:1,
                paddingTop:0,paddingRight:0,paddingBottom:0,paddingLeft:0,
                    thickness:2,format:'CODE128',displayValue:true,fillColor:'#fff',decimals:2,asPercent:false,
                    lineHeight:1.2,objectFit:'contain'
            }
        };
        if(type==='qr'){ n.width=1;n.height=1 }
        if(type==='barcode'){ n.width=2;n.height=.8 }
        if(type==='line'){ n.height=.02;n.width=2 }
        if(type==='box'){ n.width=1.5;n.height=1 }
            if(type==='image'){ n.width=2;n.height=2; n.props.objectFit='contain' }
        S.push(n);
        setSelection([n.id]);
            saveCurrentDesign();
            saveCurrentDesign();
    }

    function dupSelected(){
        if(selectedIds.length===0) return;
        pushBeforeChange();
        const mz = S.length>0 ? Math.max(...S.map(e=>e.zIndex||0)) : 0;
        const newIds = [];
        selectedIds.forEach((id, idx)=>{
            const el = S.find(e=>e.id===id);
            if(!el) return;
            const copy = deepCopy(el);
            copy.id = `el_${Date.now()}_${idx}`;
            copy.x = Math.min(el.x + 0.2, W - el.width);
            copy.y = Math.min(el.y + 0.2, H - el.height);
            copy.zIndex = mz + idx + 1;
            S.push(copy);
            newIds.push(copy.id);
        });
        setSelection(newIds);
            saveCurrentDesign();
            saveCurrentDesign();
    }

    function bringToFront(){
        if(selectedIds.length===0) return;
        pushBeforeChange();
        let mz = S.length>0 ? Math.max(...S.map(e=>e.zIndex||0)) : 0;
        selectedIds.forEach(id=>{
            const el = S.find(e=>e.id===id);
            if(el){ mz++; el.zIndex = mz; }
        });
            render(); saveCurrentDesign();
    }

    function sendToBack(){
        if(selectedIds.length===0) return;
        pushBeforeChange();
            // Calculate minimum zIndex excluding selected elements
            const unselected = S.filter(e => !selectedIds.includes(e.id));
            let mn = unselected.length > 0 ? Math.min(...unselected.map(e=>e.zIndex||0)) : 0;
            
            // If minimum is 0 or less, normalize all zIndex to be >= 0 first
            if(mn <= 0){
                const allMinZ = Math.min(...S.map(e=>e.zIndex||0));
                if(allMinZ < 0){
                    // Shift all elements up to make minimum 0
                    const shift = Math.abs(allMinZ);
                    S.forEach(e => {
                        if(!selectedIds.includes(e.id)){
                            e.zIndex = (e.zIndex || 0) + shift;
                        }
                    });
                    mn = shift;
                } else {
                    mn = 0;
                }
            }
            
            // Set selected elements to be just below the minimum (starting from mn-1)
        selectedIds.forEach((id, idx)=>{
            const el = S.find(e=>e.id===id);
                if(el){ 
                    el.zIndex = mn - (idx + 1);
                }
            });
            
            // Normalize all zIndex to be >= 0 to avoid rendering issues
            const finalMinZ = Math.min(...S.map(e=>e.zIndex||0));
            if(finalMinZ < 0){
                const shift = Math.abs(finalMinZ);
                S.forEach(e => {
                    e.zIndex = (e.zIndex || 0) + shift;
                });
            }
            
            render(); saveCurrentDesign();
    }

    function deleteSelected(){
        if(selectedIds.length===0) return;
        pushBeforeChange();
            // Remove elements from groups first
            selectedIds.forEach(id => {
                groups = groups.map(group => ({
                    ...group,
                    elementIds: group.elementIds.filter(eid => eid !== id)
                })).filter(group => group.elementIds.length > 0);
            });
        S = S.filter(e => !selectedIds.includes(e.id));
        selectedIds = [];
        render(); updateProps(); updateBtns();
            saveCurrentDesign();
            saveCurrentDesign();
            }

        // ---------- Grouping functions ----------
        function getGroupForElement(elementId){
            return groups.find(g => g.elementIds.includes(elementId));
        }

        function getGroupBounds(elementIds){
            if(elementIds.length === 0) return null;
            const elements = elementIds.map(id => S.find(e => e.id === id)).filter(Boolean);
            if(elements.length === 0) return null;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            elements.forEach(el => {
                const bounds = getRotatedBounds(el);
                const left = el.x;
                const top = el.y;
                const right = left + bounds.width;
                const bottom = top + bounds.height;
                
                minX = Math.min(minX, left);
                minY = Math.min(minY, top);
                maxX = Math.max(maxX, right);
                maxY = Math.max(maxY, bottom);
            });
            
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        function groupSelected(){
            if(selectedIds.length < 2) return;
            pushBeforeChange();
            
            // Check if any element is already in a group
            const alreadyGrouped = selectedIds.some(id => getGroupForElement(id));
            if(alreadyGrouped){
                msg('Some elements are already in a group. Ungroup them first.');
                return;
            }
            
            // Create new group
            const groupId = `group_${Date.now()}`;
            const bounds = getGroupBounds(selectedIds);
            groups.push({
                id: groupId,
                elementIds: [...selectedIds],
                bounds: bounds,
                originalBounds: {...bounds}
            });
            
            render(); updateProps(); updateBtns();
            saveCurrentDesign();
            msg('Elements grouped');
        }
        
        function scaleGroup(group, scale){
            if(!group || !group.elementIds || group.elementIds.length === 0) return;
            if(scale <= 0) return;
            
            pushBeforeChange();
            
            // Get original bounds if not set
            if(!group.originalBounds){
                group.originalBounds = getGroupBounds(group.elementIds);
            }
            
            const originalBounds = group.originalBounds;
            
            // Store original element states if not already stored
            const originalElements = {};
            group.elementIds.forEach(elementId => {
                const el = S.find(e => e.id === elementId);
                if(el){
                    // Check if we need to store original values
                    const needsStorage = !originalElements[elementId];
                    if(needsStorage){
                        originalElements[elementId] = {
                            x: el.x,
                            y: el.y,
                            width: el.width,
                            height: el.height,
                            props: deepCopy(el.props)
                        };
                    }
                }
            });
            
            // Apply uniform scaling to all elements in group
            group.elementIds.forEach(elementId => {
                const el = S.find(e => e.id === elementId);
                if(!el) return;
                
                const orig = originalElements[elementId];
                if(!orig) return;
                
                // Calculate relative position from group origin
                const relX = orig.x - originalBounds.x;
                const relY = orig.y - originalBounds.y;
                
                // Scale position and size uniformly (snapped to pixel precision)
                el.x = snapToPixel(originalBounds.x + relX * scale);
                el.y = snapToPixel(originalBounds.y + relY * scale);
                el.width = snapToPixel(orig.width * scale);
                el.height = snapToPixel(orig.height * scale);
                
                // Scale all size-related properties proportionally (rounded to 1 decimal)
                if(el.props){
                    // Font size
                    if(orig.props.fontSize !== undefined){
                        el.props.fontSize = Math.round(Math.max(6, orig.props.fontSize * scale) * 10) / 10;
                    }
                    // Padding
                    if(orig.props.paddingTop !== undefined) el.props.paddingTop = Math.round(orig.props.paddingTop * scale * 10) / 10;
                    if(orig.props.paddingRight !== undefined) el.props.paddingRight = Math.round(orig.props.paddingRight * scale * 10) / 10;
                    if(orig.props.paddingBottom !== undefined) el.props.paddingBottom = Math.round(orig.props.paddingBottom * scale * 10) / 10;
                    if(orig.props.paddingLeft !== undefined) el.props.paddingLeft = Math.round(orig.props.paddingLeft * scale * 10) / 10;
                    // Border width
                    if(orig.props.borderWidth !== undefined) el.props.borderWidth = Math.round(Math.max(0.1, orig.props.borderWidth * scale) * 10) / 10;
                    // Thickness (for lines and boxes)
                    if(orig.props.thickness !== undefined) el.props.thickness = Math.round(Math.max(0.1, orig.props.thickness * scale) * 10) / 10;
                    // Border radius
                    if(orig.props.borderRadiusTopLeft !== undefined) el.props.borderRadiusTopLeft = Math.round(orig.props.borderRadiusTopLeft * scale * 10) / 10;
                    if(orig.props.borderRadiusTopRight !== undefined) el.props.borderRadiusTopRight = Math.round(orig.props.borderRadiusTopRight * scale * 10) / 10;
                    if(orig.props.borderRadiusBottomRight !== undefined) el.props.borderRadiusBottomRight = Math.round(orig.props.borderRadiusBottomRight * scale * 10) / 10;
                    if(orig.props.borderRadiusBottomLeft !== undefined) el.props.borderRadiusBottomLeft = Math.round(orig.props.borderRadiusBottomLeft * scale * 10) / 10;
                }
            });
            
            // Update group bounds
            group.bounds = getGroupBounds(group.elementIds);
            
            render();
            updateProps();
            saveCurrentDesign();
        }

        function ungroupSelected(){
            if(selectedIds.length === 0) return;
            pushBeforeChange();
            
            let ungrouped = false;
            selectedIds.forEach(id => {
                const groupIndex = groups.findIndex(g => g.elementIds.includes(id));
                if(groupIndex !== -1){
                    groups.splice(groupIndex, 1);
                    ungrouped = true;
                }
            });
            
            if(ungrouped){
                render(); updateProps(); updateBtns();
                saveCurrentDesign();
                msg('Group ungrouped');
            }
        }

        // ---------- Import ----------
        function importFromFile(fileContent){
            try{
                let parsed = JSON.parse(fileContent);
                let importedProfiles = null;
                
                // Handle new format (v2) with profiles
                if(parsed && parsed.version === 2 && parsed.profiles){
                    importedProfiles = parsed.profiles;
                }
                // Handle old format (v1) - migrate to new format
                else if(parsed && (parsed.data || Array.isArray(parsed) || parsed.layout)){
                    const oldData = parsed.data || (Array.isArray(parsed) ? parsed : parsed.layout);
                    importedProfiles = {
                        '8x5': {
                            width: 8,
                            height: 5,
                            designs: {
                                'default': {
                                    canvas1: oldData, // Keep original, normalize when adding
                                    canvas2: [],
                                    canvas2Enabled: false,
                                    sequenceEnabled: false,
                                    sequenceCountColumn: ''
                                }
                            }
                        }
                    };
                }
                else {
                    throw new Error('Unknown layout structure');
                }
                
                if(!importedProfiles) return false;
                
                // Add imported elements to current canvas/design
                // Save current design first
                saveCurrentDesign();
                
                // Get current profile and design
                const currentProf = profiles[currentProfile];
                if(!currentProf) return false;
                const currentDes = currentProf.designs[currentDesign];
                if(!currentDes) return false;
                
                // Get the profile and design from imported data
                // Use saved currentProfile/currentDesign if available, otherwise use first
                let importedProfKey = parsed.currentProfile;
                if(!importedProfKey || !importedProfiles[importedProfKey]){
                    importedProfKey = Object.keys(importedProfiles)[0];
                }
                if(!importedProfKey) return false;
                
                const importedProf = importedProfiles[importedProfKey];
                let importedDesKey = parsed.currentDesign;
                if(!importedDesKey || !importedProf.designs[importedDesKey]){
                    importedDesKey = Object.keys(importedProf.designs)[0];
                }
                if(!importedDesKey) return false;
                
                const importedDes = importedProf.designs[importedDesKey];
                
                // Migrate old format if needed
                // Don't normalize yet - preserve original zIndex values
                let designData = importedDes;
                if(Array.isArray(importedDes)){
                    designData = {
                        canvas1: importedDes, // Keep original, normalize when adding
                        canvas2: [],
                        canvas2Enabled: false,
                        sequenceEnabled: false
                    };
                } else if(!importedDes.canvas1 || !importedDes.canvas2){
                    designData = {
                        canvas1: (importedDes.canvas1 || []), // Keep original
                        canvas2: (importedDes.canvas2 || []), // Keep original
                        canvas2Enabled: importedDes.canvas2Enabled || false,
                        sequenceEnabled: importedDes.sequenceEnabled || false,
                    };
                }
                
                // Get the canvas data to import
                // Use saved currentCanvas if available, otherwise use current canvas
                const importedCanvas = (parsed.currentCanvas === 1 || parsed.currentCanvas === 2) ? parsed.currentCanvas : currentCanvas;
                const importedCanvasData = designData[`canvas${importedCanvas}`] || [];
                
                // Add imported elements to current canvas
                // Generate new IDs to avoid conflicts, but preserve original zIndex values
                importedCanvasData.forEach((el, idx) => {
                    // Preserve original zIndex BEFORE normalization
                    const originalZIndex = el.zIndex !== undefined && el.zIndex !== null ? Number(el.zIndex) : null;
                    const newEl = deepCopy(normalizeElement(el));
                    newEl.id = `el_${Date.now()}_${idx}`;
                    // Restore original zIndex if it existed, otherwise use a default based on position
                    if(originalZIndex !== null){
                        newEl.zIndex = originalZIndex;
                    } else {
                        // If no zIndex in original, assign based on position
                        const maxZ = S.length > 0 ? Math.max(...S.map(e => e.zIndex || 0)) : 0;
                        newEl.zIndex = maxZ + idx + 1;
                    }
                    S.push(newEl);
                });
                
                // Save the updated design
                saveCurrentDesign();
                
                render();
                updateProps();
            resetHistory();
                msg(`Imported ${importedCanvasData.length} element(s) to current canvas!`);
            return true;
        }catch(e){
                console.error('Parse error while importing layout:',e);
                msg('Error importing layout: invalid JSON', true, 4000);
            return false;
        }
    }

    function exportToFile(){
            // Ensure current design is saved before exporting
            // This saves the current S array to the current design
            saveCurrentDesign();
            
            // Verify current profile and design exist
            const profile = profiles[currentProfile];
            if(!profile){
                msg('Error: Current profile not found', true);
                return;
            }
            if(!profile.designs[currentDesign]){
                msg('Error: Current design not found', true);
                return;
            }
            
            // Double-check: ensure current design has the current canvas data
            const design = profile.designs[currentDesign];
            const canvasKey = `canvas${currentCanvas}`;
            // Update the design with current S array to ensure it's saved
            design[canvasKey] = deepCopy(S);
            
            const payloadObj = { 
                version: 2, 
                timestamp: Date.now(), 
                profiles: profiles,
                currentProfile: currentProfile,
                currentDesign: currentDesign,
                currentCanvas: currentCanvas
            };
        const blob = new Blob([JSON.stringify(payloadObj,null,2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); 
            a.href = url; 
            a.download = `label-layout-${currentProfile}-${currentDesign}.json`;
            document.body.appendChild(a); 
            a.click(); 
            a.remove(); 
            URL.revokeObjectURL(url);
        }

        function printBothCanvases(){
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[currentDesign]) return;
            const design = profile.designs[currentDesign];
            const canvas2Flag = design.canvas2Enabled || false;
            // Sequence mode is always enabled
            const sequenceEnabled = true;
            // Validate sequence mode
            if(!globalSequenceCountColumn){
                msg('Error: No count column selected. Please select a column in Design Settings.', true);
                return;
            }
            if(!R || !Object.prototype.hasOwnProperty.call(R, globalSequenceCountColumn)){
                msg('Error: Count column not found in current record', true);
                return;
            }
            
            // Save current canvas
            saveCurrentDesign();
            
            // Store original state
            const prevSel = deepCopy(selectedIds);
            const prevCanvas = currentCanvas;
            const prevS = deepCopy(S);
            
            // Calculate count for sequence mode (always enabled)
            const countRaw = R[globalSequenceCountColumn];
            const count = Math.max(0, Math.floor(Number(countRaw)));
            if(count <= 0){
                msg('Warning: Count value is 0 or invalid, no labels will be printed', true);
                return;
            }
            
            // Create print container
            const printContainer = document.createElement('div');
            printContainer.className = 'print-container';
            printContainer.style.position = 'absolute';
            printContainer.style.left = '-9999px';
            printContainer.style.top = '0';
            printContainer.style.width = `${profile.width}cm`;
            // Height is auto - pages will be stacked naturally
            printContainer.style.height = 'auto';
            
            // Calculate total pages
            const totalPages = canvas2Flag ? count * 2 : count;
            
            // Helper function to render canvas to print page
            function renderCanvasToPage(canvasNum, sequenceIndex = 1, isLastPage = false){
                const canvasData = design[`canvas${canvasNum}`] || [];
                const tempS = canvasData.map(normalizeElement);
                
                const page = document.createElement('div');
                page.className = 'print-page';
                page.style.width = `${profile.width}cm`;
                page.style.height = `${profile.height}cm`;
                page.style.position = 'relative';
                page.style.background = '#fff';
                page.style.overflow = 'hidden';
                // Set pageBreakAfter only for last page - let CSS handle the rest
                if(isLastPage){
                    page.style.pageBreakAfter = 'auto';
                }
                // No marginTop or offsetY - pages are created in sequence
                
                // Render elements
                const sorted = tempS.slice().sort((a,b)=> (a.zIndex||0) - (b.zIndex||0));
                sorted.forEach(el=>{
                    const d = document.createElement('div');
                    d.classList.add('label-element');
                    d.style.position = 'absolute';
                    d.style.left = `${el.x}cm`;
                    d.style.top = `${el.y}cm`;
                    // For lines, don't set height in cm initially - it will be set in px later
                    if(el.type !== 'line'){
                        d.style.width = `${el.width}cm`;
                        d.style.height = `${el.height}cm`;
                    } else {
                        d.style.width = `${el.width}cm`;
                        // Height will be set in px in the line case below
                    }
                    d.style.zIndex = el.zIndex || 0;
                    d.style.fontSize = `${el.props.fontSize || 16}px`;
                    const fontWeight = el.props.fontWeight;
                    if(typeof fontWeight === 'number'){
                        d.style.fontWeight = fontWeight;
                    } else {
                        d.style.fontWeight = fontWeight || 'normal';
                    }
                    d.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                    d.style.lineHeight = el.props.lineHeight !== undefined ? String(el.props.lineHeight) : '1.2';
                    const justifyMap = { left: 'flex-start', center: 'center', right: 'flex-end' };
                    const alignMap = { top: 'flex-start', middle: 'center', bottom: 'flex-end' };
                    if(el.type !== 'line'){
                        d.style.display = 'flex';
                        d.style.alignItems = alignMap[el.props.valign] || 'flex-start';
                        d.style.justifyContent = justifyMap[el.props.textAlign] || 'flex-start';
                        // Use pre-wrap to preserve line breaks from textarea
                        if(el.type === 'text' || el.type === 'data'){
                            d.style.whiteSpace = 'pre-wrap';
                        } else {
                            d.style.whiteSpace = 'normal';
                        }
                    } else {
                        d.style.display = 'block';
                        d.style.whiteSpace = '';
                    }
                    d.style.textAlign = el.props.textAlign || 'left';
                    // For lines, color is handled separately via background
                    if(el.type !== 'line'){
                        d.style.color = el.props.color || '#000000';
                    }
                    d.style.boxSizing = 'border-box';
                    const rotation = Number(el.props.rotation) || 0;
                    d.style.transform = `rotate(${rotation}deg)`;
                    d.style.transformOrigin = 'center center';
                    
                    if((el.type === 'text' || el.type === 'data')){
                        const pt = Number.isFinite(Number(el.props.paddingTop)) ? Number(el.props.paddingTop) : 0;
                        const pr = Number.isFinite(Number(el.props.paddingRight)) ? Number(el.props.paddingRight) : 0;
                        const pb = Number.isFinite(Number(el.props.paddingBottom)) ? Number(el.props.paddingBottom) : 0;
                        const pl = Number.isFinite(Number(el.props.paddingLeft)) ? Number(el.props.paddingLeft) : 0;
                        d.style.padding = `${pt}cm ${pr}cm ${pb}cm ${pl}cm`;
                    } else {
                        d.style.padding = '';
                    }
                    
                        // Apply borders for elements with showBorder enabled
                    if(el.props.showBorder && el.type !== 'box'){
                        const borderWidth = `${Number(el.props.borderWidth)||1}px`;
                        const borderColor = el.props.borderColor || '#000';
                        const borderStyle = 'solid';
                        
                        // Apply borders only to enabled sides
                        d.style.borderTop = (el.props.borderTop !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                        d.style.borderRight = (el.props.borderRight !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                        d.style.borderBottom = (el.props.borderBottom !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                        d.style.borderLeft = (el.props.borderLeft !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                            
                            // Force borders to print
                            d.style.printColorAdjust = 'exact';
                            d.style.webkitPrintColorAdjust = 'exact';
                        
                        // Apply border radius (individual corners)
                        const brTL = Number(el.props.borderRadiusTopLeft) || 0;
                        const brTR = Number(el.props.borderRadiusTopRight) || 0;
                        const brBR = Number(el.props.borderRadiusBottomRight) || 0;
                        const brBL = Number(el.props.borderRadiusBottomLeft) || 0;
                        if(brTL > 0 || brTR > 0 || brBR > 0 || brBL > 0){
                            d.style.borderRadius = `${brTL}px ${brTR}px ${brBR}px ${brBL}px`;
                        } else {
                            d.style.borderRadius = '';
                        }
                        } else if(el.type !== 'box' && el.type !== 'line'){
                            // Only apply transparent border if showBorder is not enabled
                            // This ensures borders are visible when showBorder is true
                            if(!el.props.showBorder){
                                d.style.border = '1px solid transparent';
                            }
                        }
                        
                        // Apply border radius for box elements (independent of showBorder)
                        if(el.type === 'box'){
                            const brTL = Number(el.props.borderRadiusTopLeft) || 0;
                            const brTR = Number(el.props.borderRadiusTopRight) || 0;
                            const brBR = Number(el.props.borderRadiusBottomRight) || 0;
                            const brBL = Number(el.props.borderRadiusBottomLeft) || 0;
                            if(brTL > 0 || brTR > 0 || brBR > 0 || brBL > 0){
                                d.style.borderRadius = `${brTL}px ${brTR}px ${brBR}px ${brBL}px`;
                    } else {
                                d.style.borderRadius = '';
                            }
                    }
                    
                    // Content
                    switch(el.type){
                        case 'text': {
                            const span = document.createElement('div');
                            span.style.display='block';
                            span.style.pointerEvents='none';
                            
                            // Set whiteSpace and width based on textOverflow mode
                            const overflowMode = el.props.textOverflow || 'clip';
                            if(overflowMode === 'squeeze'){
                                span.style.whiteSpace = 'nowrap'; // No wrapping for squeeze
                                span.style.width = 'auto'; // Allow natural text width for squeeze
                                span.style.overflow = 'visible'; // Don't clip compressed text
                            } else {
                                span.style.width = '100%';
                                span.style.overflow = 'hidden';
                                span.style.whiteSpace = 'pre-wrap'; // Allow wrapping for clip and auto-scale
                            }
                            span.style.wordWrap='break-word';
                            
                            span.textContent = getData(el, sequenceIndex);
                            // Copy font styles to span for overflow calculation
                            span.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                            span.style.fontSize = (el.props.fontSize || 16) + 'px';
                            const fontWeight = el.props.fontWeight;
                            if(typeof fontWeight === 'number'){
                                span.style.fontWeight = fontWeight;
                            } else {
                                span.style.fontWeight = fontWeight || 'normal';
                            }
                            span.style.lineHeight = el.props.lineHeight !== undefined ? String(el.props.lineHeight) : '1.2';
                            span.style.color = el.props.color || '#000000';
                            
                            d.appendChild(span);
                            break;
                        }
                        case 'data': {
                            const span = document.createElement('div');
                            span.style.display='block';
                            span.style.width='100%';
                            span.style.pointerEvents='none';
                            span.style.overflow='hidden';
                            span.style.wordWrap='break-word';
                            span.style.whiteSpace='pre-wrap'; // Always allow wrapping first
                            
                            span.textContent = getData(el, sequenceIndex);
                            // Copy font styles to span for overflow calculation
                            span.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                            span.style.fontSize = (el.props.fontSize || 16) + 'px';
                            const fontWeight = el.props.fontWeight;
                            if(typeof fontWeight === 'number'){
                                span.style.fontWeight = fontWeight;
                            } else {
                                span.style.fontWeight = fontWeight || 'normal';
                            }
                            span.style.lineHeight = el.props.lineHeight !== undefined ? String(el.props.lineHeight) : '1.2';
                            span.style.color = el.props.color || '#000000';
                            
                            d.appendChild(span);
                            break;
                        }
                        case 'line':
                            // For lines, use explicit background color and ensure visibility
                            const lineColor = el.props.color || '#000000';
                            d.style.background = lineColor;
                            d.style.backgroundColor = lineColor;
                            d.style.height = `${el.props.thickness || 2}px`;
                            d.style.width = `${el.width}cm`;
                            d.style.border = 'none';
                            d.style.display = 'block';
                            d.style.margin = '0';
                            d.style.padding = '0';
                            d.style.overflow = 'visible';
                            d.style.minHeight = `${el.props.thickness || 2}px`;
                            d.style.maxHeight = `${el.props.thickness || 2}px`;
                            d.style.boxSizing = 'border-box';
                            // Force browsers to print background colors
                            d.style.printColorAdjust = 'exact';
                            d.style.webkitPrintColorAdjust = 'exact';
                            // Add a non-breaking space to ensure the div has content (invisible but ensures rendering)
                            d.innerHTML = '&nbsp;';
                            d.style.color = 'transparent';
                            d.style.fontSize = '0';
                            break;
                        case 'box':
                                const printBoxThickness = el.props.thickness !== undefined ? Number(el.props.thickness) : 2;
                                if(printBoxThickness > 0){
                                    d.style.border = `${printBoxThickness}px solid ${el.props.color || '#000000'}`;
                                    d.style.borderWidth = `${printBoxThickness}px`;
                                } else {
                                    d.style.border = 'none';
                                    d.style.borderWidth = '0';
                                    d.style.borderStyle = 'none';
                                    d.style.borderColor = 'transparent';
                                }
                            d.style.backgroundColor = el.props.fillColor || 'transparent';
                            break;
                        case 'qr': {
                            const c = getData(el, sequenceIndex);
                            const q = document.createElement('img');
                            const dpi = 37.795276;
                            const qs = Math.min(el.width, el.height) * dpi;
                            q.src = `https://api.qrserver.com/v1/create-qr-code/?size=${Math.round(qs)}x${Math.round(qs)}&data=${encodeURIComponent(c)}`;
                            q.style.pointerEvents='none';
                            q.style.width='100%';
                            q.style.height='100%';
                            q.style.objectFit='contain';
                            d.appendChild(q);
                            break;
                        }
                        case 'barcode': {
                            const c = getData(el, sequenceIndex) || '';
                            let prefix = el.props.prefix || '';
                            let suffix = el.props.suffix || '';
                            
                            // Apply sequence placeholder to prefix and suffix
                            prefix = replaceColumnSyntax(prefix, el);
                            prefix = applySequencePlaceholder(prefix, sequenceIndex);
                            suffix = replaceColumnSyntax(suffix, el);
                            suffix = applySequencePlaceholder(suffix, sequenceIndex);
                            
                            // Combine prefix + code + suffix into the barcode value
                            const barcodeValue = prefix + String(c) + suffix;
                            
                            // Calculate dimensions considering padding and borders FIRST
                            const paddingTop = (Number(el.props.paddingTop) || 0) * PIXELS_PER_CM;
                            const paddingBottom = (Number(el.props.paddingBottom) || 0) * PIXELS_PER_CM;
                            const paddingLeft = (Number(el.props.paddingLeft) || 0) * PIXELS_PER_CM;
                            const paddingRight = (Number(el.props.paddingRight) || 0) * PIXELS_PER_CM;
                            const borderWidth = (Number(el.props.thickness) || 0);
                            
                            const containerWidthPx = el.width * PIXELS_PER_CM;
                            const containerHeightPx = el.height * PIXELS_PER_CM;
                            const availableWidth = containerWidthPx - paddingLeft - paddingRight - (borderWidth * 2);
                            const availableHeight = containerHeightPx - paddingTop - paddingBottom - (borderWidth * 2);
                            
                            // Create SVG for barcode - fill full container
                            const sv = document.createElementNS('http://www.w3.org/2000/svg','svg');
                            sv.style.pointerEvents='none';
                            sv.style.width = '100%';
                            sv.style.height = '100%';
                            sv.style.display = 'block';
                            sv.style.overflow = 'visible';
                            d.appendChild(sv);
                            
                            try{
                                const barcodeWidth = Math.max(50, availableWidth);
                                const pxHeight = availableHeight; // Use full available height, no minimum
                                
                                // Calculate width per bar based on available width (estimate ~50 bars for typical barcode)
                                const estimatedBars = 50;
                                const widthPerBar = Math.max(1, barcodeWidth / estimatedBars);
                                
                                // Set explicit SVG dimensions
                                sv.setAttribute('width', barcodeWidth.toString());
                                sv.setAttribute('height', pxHeight.toString());
                                sv.setAttribute('viewBox', `0 0 ${barcodeWidth} ${pxHeight}`);
                                sv.setAttribute('preserveAspectRatio', 'none'); // No aspect ratio preservation - fill completely
                                
                                // Generate barcode with prefix + code + suffix included
                                JsBarcode(sv, barcodeValue, {
                                    format: el.props.format || "CODE128",
                                    displayValue: el.props.displayValue !== false,
                                    width: widthPerBar,
                                    height: pxHeight,
                                    margin: 0
                                });
                            }catch(err){
                                sv.innerHTML = `<text x="10" y="20" fill="red" font-size="12">Invalid barcode</text>`;
                            }
                            break;
                        }
                        case 'image': {
                            const img = document.createElement('img');
                            img.style.pointerEvents='none';
                            img.style.width='100%';
                            img.style.height='100%';
                            img.style.objectFit = el.props.objectFit || 'contain';
                            
                            // Build Imgur URL from Grist column value
                            let imageUrl = '';
                            if(el.props.boundColumn && R && Object.prototype.hasOwnProperty.call(R, el.props.boundColumn)){
                                const imgurId = R[el.props.boundColumn];
                                if(imgurId){
                                    const id = String(imgurId).trim();
                                    if(id){
                                        // Construct Imgur URL: https://i.imgur.com/{id}.jpg
                                        // If the value already contains http/https, use it as-is
                                        if(id.startsWith('http://') || id.startsWith('https://')){
                                            imageUrl = id;
                                        } else {
                                            // Remove any existing extension and add .jpg
                                            const cleanId = id.replace(/\.(jpg|jpeg|png|gif|webp)$/i, '');
                                            imageUrl = `https://i.imgur.com/${cleanId}.jpg`;
                                        }
                                    }
                                }
                            }
                            
                            if(imageUrl){
                                img.src = imageUrl;
                                img.onerror = function(){
                                    img.style.display = 'none';
                                    const errorDiv = document.createElement('div');
                                    errorDiv.style.width = '100%';
                                    errorDiv.style.height = '100%';
                                    errorDiv.style.display = 'flex';
                                    errorDiv.style.alignItems = 'center';
                                    errorDiv.style.justifyContent = 'center';
                                    errorDiv.style.color = '#999';
                                    errorDiv.style.fontSize = '12px';
                                    errorDiv.textContent = 'Image not found';
                                    d.appendChild(errorDiv);
                                };
                            } else {
                                // Show placeholder when no image
                                img.style.display = 'none';
                                const placeholder = document.createElement('div');
                                placeholder.style.width = '100%';
                                placeholder.style.height = '100%';
                                placeholder.style.display = 'flex';
                                placeholder.style.alignItems = 'center';
                                placeholder.style.justifyContent = 'center';
                                placeholder.style.color = '#ccc';
                                placeholder.style.fontSize = '12px';
                                placeholder.style.border = '1px dashed #ccc';
                                placeholder.textContent = 'No image';
                                d.appendChild(placeholder);
                            }
                            d.appendChild(img);
                            break;
                        }
                    }
                    
                    page.appendChild(d);
                });
                
                return page;
            }
            
            // Add print container to DOM first so measurements work correctly
            document.body.appendChild(printContainer);
            
            // Sequence mode is always enabled - render multiple labels stacked vertically
            // Each pair (canvas1 + canvas2) shares the same sequenceIndex
            let pageIndex = 0;
            for(let sequenceIndex = 1; sequenceIndex <= count; sequenceIndex++){
                // Add canvas 1 for this sequence index
                pageIndex++;
                const isLastPage1 = pageIndex === totalPages;
                const page1 = renderCanvasToPage(1, sequenceIndex, isLastPage1);
                printContainer.appendChild(page1);
                
                // Add canvas 2 with the same sequence index if enabled
                if(canvas2Flag){
                    pageIndex++;
                    const isLastPage2 = pageIndex === totalPages;
                    const page2 = renderCanvasToPage(2, sequenceIndex, isLastPage2);
                    printContainer.appendChild(page2);
                }
            }
            
            // Store pages for text overflow handling
            const pages = printContainer.querySelectorAll('.print-page');
            let page1 = null, page2 = null;
            if(pages.length > 0) page1 = pages[0];
            if(canvas2Flag && pages.length > 1) page2 = pages[1];
            
            // Now apply text overflow handling after all elements are in DOM
            // Need to get the canvas data for each page
            const canvas1Data = design.canvas1 || [];
            const canvas2Data = design.canvas2 || [];
            
            // Get all pages (works for both normal and sequence mode)
            const allPages = printContainer.querySelectorAll('.print-page');
            allPages.forEach((page) => {
                // Determine which canvas this page belongs to based on position
                // In sequence mode, pages alternate: canvas1, canvas2 (if enabled), canvas1, canvas2, ...
                // In normal mode: canvas1, canvas2 (if enabled)
                const pageIndex = Array.from(allPages).indexOf(page);
                let canvasData, canvasNum;
                if(sequenceEnabled){
                    if(canvas2Flag){
                        // Even index (0, 2, 4...) = canvas1, odd (1, 3, 5...) = canvas2
                        canvasNum = (pageIndex % 2 === 0) ? 1 : 2;
                    } else {
                        // All pages are canvas1
                        canvasNum = 1;
                    }
                } else {
                    // Normal mode: first page is canvas1, second (if exists) is canvas2
                    canvasNum = (pageIndex === 0) ? 1 : 2;
                }
                canvasData = canvasNum === 1 ? canvas1Data : canvas2Data;
                
                const tempS = canvasData.map(normalizeElement);
                const sorted = tempS.slice().sort((a,b)=> (a.zIndex||0) - (b.zIndex||0));
                
                page.querySelectorAll('.label-element').forEach((d, index) => {
                    if(index < sorted.length){
                        const el = sorted[index];
                        if((el.type === 'text' || el.type === 'data') && (el.props.textOverflow === 'auto-scale' || el.props.textOverflow === 'squeeze')){
                            const span = d.querySelector('div[style*="pointer-events: none"]');
                            if(span){
                                // Use real browser dimensions
                                const containerWidth = d.offsetWidth;
                                const containerHeight = d.offsetHeight;
                                applyTextOverflow(span, el, containerWidth, containerHeight, true);
                            }
                        }
                    }
                });
            });
            
            // Wait for all images to load before printing
            const allImages = printContainer.querySelectorAll('img');
            const imagePromises = Array.from(allImages).map(img => {
                // If image is already loaded (complete), resolve immediately
                if(img.complete && img.naturalWidth > 0){
                    return Promise.resolve();
                }
                // Otherwise wait for load or error
                return new Promise((resolve) => {
                    img.onload = resolve;
                    img.onerror = resolve; // Resolve even on error so print can proceed
                    // Timeout after 5 seconds to prevent hanging
                    setTimeout(resolve, 5000);
                });
            });
            
            // Wait for all images, then proceed with print
            Promise.all(imagePromises).then(() => {
                // Update print CSS for multiple pages
                const styleId = 'dynamic-print-css';
                let styleEl = document.getElementById(styleId);
                if(!styleEl){
                    styleEl = document.createElement('style');
                    styleEl.id = styleId;
                    document.head.appendChild(styleEl);
                }
                styleEl.textContent = `
                    @media print{
                        @page{size:${profile.width}cm ${profile.height}cm;margin:0}
                        html,body{margin:0!important;padding:0!important;background:#fff!important;width:${profile.width}cm!important;height:auto!important}
                        #toolbar,#sidebar,#marquee,.status-message{display:none!important}
                        .print-page{width:${profile.width}cm!important;height:${profile.height}cm!important;page-break-inside:avoid!important;overflow:visible!important;background:#fff!important;position:relative!important;margin:0!important;padding:0!important;display:block!important;box-sizing:border-box!important}
                        .print-page:not(:last-child){page-break-after:always!important}
                        .print-page:last-child{page-break-after:auto!important}
                        .print-container{display:block!important;position:static!important;left:auto!important;top:auto!important}
                        #main-content,#canvas-container,#canvas-wrapper,#label-canvas{display:none!important}
                        .label-element{print-color-adjust:exact!important;-webkit-print-color-adjust:exact!important}
                    }
                `;
                
                // Print
                window.print();
                
                // Restore state after a delay
                setTimeout(()=>{
                    currentCanvas = prevCanvas;
                    S = prevS;
                    selectedIds = prevSel;
                    render();
                    updateProps();
                    if(printContainer.parentNode){
                        document.body.removeChild(printContainer);
                    }
                    updatePrintCSS(); // Restore normal print CSS
                }, 100);
            });
    }

    function printSingle(){
        try {
            const profile = profiles[currentProfile];
            if(!profile || !profile.designs[currentDesign]) {
                msg('Error: No profile or design selected', true);
                return;
            }
            const design = profile.designs[currentDesign];
            const canvas2Flag = design.canvas2Enabled || false;
            
            // Ask user for sequence number
            const sequenceInput = prompt('Enter sequence number:', '1');
            if(sequenceInput === null) return; // User cancelled
            
            const sequenceIndex = Math.max(1, Math.floor(Number(sequenceInput)));
            if(isNaN(sequenceIndex) || sequenceIndex < 1){
                msg('Error: Invalid sequence number', true);
                return;
            }
            
            // Save current canvas
            saveCurrentDesign();
            
            // Store original state
            const prevSel = deepCopy(selectedIds);
            const prevCanvas = currentCanvas;
            const prevS = deepCopy(S);
        
        // Create print container for single label
        const printContainer = document.createElement('div');
        printContainer.className = 'print-container';
        printContainer.style.position = 'absolute';
        printContainer.style.left = '-9999px';
        printContainer.style.top = '0';
        printContainer.style.width = `${profile.width}cm`;
        // Height is auto - pages will be stacked naturally
        printContainer.style.height = 'auto';
        
        // Calculate total pages
        const totalPages = canvas2Flag ? 2 : 1;
        
        // Helper function to render canvas to print page (identical to printBothCanvases)
        function renderCanvasToPage(canvasNum, sequenceIndex = 1, isLastPage = false){
            const canvasData = design[`canvas${canvasNum}`] || [];
            const tempS = canvasData.map(normalizeElement);
            
            const page = document.createElement('div');
            page.className = 'print-page';
            page.style.width = `${profile.width}cm`;
            page.style.height = `${profile.height}cm`;
            page.style.position = 'relative';
            page.style.background = '#fff';
            page.style.overflow = 'hidden';
            // Set pageBreakAfter only for last page - let CSS handle the rest
            if(isLastPage){
                page.style.pageBreakAfter = 'auto';
            }
            // No marginTop or offsetY - pages are created in sequence
            
            // Render elements
            const sorted = tempS.slice().sort((a,b)=> (a.zIndex||0) - (b.zIndex||0));
            sorted.forEach(el=>{
                const d = document.createElement('div');
                d.classList.add('label-element');
                d.style.position = 'absolute';
                d.style.left = `${el.x}cm`;
                d.style.top = `${el.y}cm`;
                if(el.type !== 'line'){
                    d.style.width = `${el.width}cm`;
                    d.style.height = `${el.height}cm`;
                } else {
                    d.style.width = `${el.width}cm`;
                }
                d.style.zIndex = el.zIndex || 0;
                d.style.fontSize = `${el.props.fontSize || 16}px`;
                const fontWeight = el.props.fontWeight;
                if(typeof fontWeight === 'number'){
                    d.style.fontWeight = fontWeight;
                } else {
                    d.style.fontWeight = fontWeight || 'normal';
                }
                d.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                d.style.lineHeight = el.props.lineHeight !== undefined ? String(el.props.lineHeight) : '1.2';
                const justifyMap = { left: 'flex-start', center: 'center', right: 'flex-end' };
                const alignMap = { top: 'flex-start', middle: 'center', bottom: 'flex-end' };
                if(el.type !== 'line'){
                    d.style.display = 'flex';
                    d.style.alignItems = alignMap[el.props.valign] || 'flex-start';
                    d.style.justifyContent = justifyMap[el.props.textAlign] || 'flex-start';
                    if(el.type === 'text' || el.type === 'data'){
                        d.style.whiteSpace = 'pre-wrap';
                    } else {
                        d.style.whiteSpace = 'normal';
                    }
                } else {
                    d.style.display = 'block';
                    d.style.whiteSpace = '';
                }
                d.style.textAlign = el.props.textAlign || 'left';
                if(el.type !== 'line'){
                    d.style.color = el.props.color || '#000000';
                }
                d.style.boxSizing = 'border-box';
                const rotation = Number(el.props.rotation) || 0;
                d.style.transform = `rotate(${rotation}deg)`;
                d.style.transformOrigin = 'center center';
                
                if((el.type === 'text' || el.type === 'data')){
                    const pt = Number.isFinite(Number(el.props.paddingTop)) ? Number(el.props.paddingTop) : 0;
                    const pr = Number.isFinite(Number(el.props.paddingRight)) ? Number(el.props.paddingRight) : 0;
                    const pb = Number.isFinite(Number(el.props.paddingBottom)) ? Number(el.props.paddingBottom) : 0;
                    const pl = Number.isFinite(Number(el.props.paddingLeft)) ? Number(el.props.paddingLeft) : 0;
                    d.style.padding = `${pt}cm ${pr}cm ${pb}cm ${pl}cm`;
                } else {
                    d.style.padding = '';
                }
                
                // Apply borders and styling (simplified - same as printBothCanvases)
                if(el.props.showBorder && el.type !== 'box'){
                    const borderWidth = `${Number(el.props.borderWidth)||1}px`;
                    const borderColor = el.props.borderColor || '#000';
                    const borderStyle = 'solid';
                    d.style.borderTop = (el.props.borderTop !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                    d.style.borderRight = (el.props.borderRight !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                    d.style.borderBottom = (el.props.borderBottom !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                    d.style.borderLeft = (el.props.borderLeft !== false) ? `${borderWidth} ${borderStyle} ${borderColor}` : 'none';
                    d.style.printColorAdjust = 'exact';
                    d.style.webkitPrintColorAdjust = 'exact';
                    const brTL = Number(el.props.borderRadiusTopLeft) || 0;
                    const brTR = Number(el.props.borderRadiusTopRight) || 0;
                    const brBR = Number(el.props.borderRadiusBottomRight) || 0;
                    const brBL = Number(el.props.borderRadiusBottomLeft) || 0;
                    if(brTL > 0 || brTR > 0 || brBR > 0 || brBL > 0){
                        d.style.borderRadius = `${brTL}px ${brTR}px ${brBR}px ${brBL}px`;
                    } else {
                        d.style.borderRadius = '';
                    }
                } else if(el.type !== 'box' && el.type !== 'line'){
                    if(!el.props.showBorder){
                        d.style.border = '1px solid transparent';
                    }
                }
                
                if(el.type === 'box'){
                    const brTL = Number(el.props.borderRadiusTopLeft) || 0;
                    const brTR = Number(el.props.borderRadiusTopRight) || 0;
                    const brBR = Number(el.props.borderRadiusBottomRight) || 0;
                    const brBL = Number(el.props.borderRadiusBottomLeft) || 0;
                    if(brTL > 0 || brTR > 0 || brBR > 0 || brBL > 0){
                        d.style.borderRadius = `${brTL}px ${brTR}px ${brBR}px ${brBL}px`;
                    } else {
                        d.style.borderRadius = '';
                    }
                }
                
                // Content - use getData with the specified sequenceIndex
                switch(el.type){
                    case 'text': {
                        const span = document.createElement('div');
                        span.style.display='block';
                        span.style.pointerEvents='none';
                        span.style.width='100%';
                        span.style.overflow='hidden';
                        span.style.wordWrap='break-word';
                        span.style.whiteSpace='pre-wrap';
                        span.textContent = getData(el, sequenceIndex);
                        span.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                        span.style.fontSize = (el.props.fontSize || 16) + 'px';
                        span.style.color = el.props.color || '#000000';
                        d.appendChild(span);
                        break;
                    }
                    case 'data': {
                        const span = document.createElement('div');
                        span.style.display='block';
                        span.style.width='100%';
                        span.style.pointerEvents='none';
                        span.style.overflow='hidden';
                        span.style.wordWrap='break-word';
                        span.style.whiteSpace='pre-wrap';
                        span.textContent = getData(el, sequenceIndex);
                        span.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
                        span.style.fontSize = (el.props.fontSize || 16) + 'px';
                        span.style.color = el.props.color || '#000000';
                        d.appendChild(span);
                        break;
                    }
                    case 'line':
                        d.style.background = el.props.color || '#000000';
                        d.style.height = `${el.props.thickness || 2}px`;
                        d.style.width = `${el.width}cm`;
                        d.style.border = 'none';
                        break;
                    case 'box':
                        const boxThickness = el.props.thickness !== undefined ? Number(el.props.thickness) : 2;
                        if(boxThickness > 0){
                            d.style.border = `${boxThickness}px solid ${el.props.color || '#000000'}`;
                        } else {
                            d.style.border = 'none';
                        }
                        d.style.backgroundColor = el.props.fillColor || 'transparent';
                        break;
                    case 'qr': {
                        const c = getData(el, sequenceIndex);
                        const q = document.createElement('img');
                        const dpi = 37.795276;
                        const qs = Math.min(el.width, el.height) * dpi;
                        q.src = `https://api.qrserver.com/v1/create-qr-code/?size=${Math.round(qs)}x${Math.round(qs)}&data=${encodeURIComponent(c)}`;
                        q.style.pointerEvents='none';
                        q.style.width='100%';
                        q.style.height='100%';
                        q.style.objectFit='contain';
                        d.appendChild(q);
                        break;
                    }
                    case 'barcode': {
                        const c = getData(el, sequenceIndex) || '';
                        let prefix = el.props.prefix || '';
                        let suffix = el.props.suffix || '';
                        prefix = replaceColumnSyntax(prefix, el);
                        prefix = applySequencePlaceholder(prefix, sequenceIndex);
                        suffix = replaceColumnSyntax(suffix, el);
                        suffix = applySequencePlaceholder(suffix, sequenceIndex);
                        
                        // Combine prefix + code + suffix into the barcode value
                        const barcodeValue = prefix + String(c) + suffix;
                        
                        // Calculate dimensions considering padding and borders FIRST
                        const paddingTop = (Number(el.props.paddingTop) || 0) * PIXELS_PER_CM;
                        const paddingBottom = (Number(el.props.paddingBottom) || 0) * PIXELS_PER_CM;
                        const paddingLeft = (Number(el.props.paddingLeft) || 0) * PIXELS_PER_CM;
                        const paddingRight = (Number(el.props.paddingRight) || 0) * PIXELS_PER_CM;
                        const borderWidth = (Number(el.props.thickness) || 0);
                        
                        const containerWidthPx = el.width * PIXELS_PER_CM;
                        const containerHeightPx = el.height * PIXELS_PER_CM;
                        const availableWidth = containerWidthPx - paddingLeft - paddingRight - (borderWidth * 2);
                        const availableHeight = containerHeightPx - paddingTop - paddingBottom - (borderWidth * 2);
                        
                        // Create SVG for barcode - fill full container
                        const sv = document.createElementNS('http://www.w3.org/2000/svg','svg');
                        sv.style.pointerEvents='none';
                        sv.style.width = '100%';
                        sv.style.height = '100%';
                        sv.style.display = 'block';
                        sv.style.overflow = 'visible';
                        d.appendChild(sv);
                        
                        try{
                            const barcodeWidth = Math.max(50, availableWidth);
                            const pxHeight = availableHeight; // Use full available height, no minimum
                            
                            // Calculate width per bar based on available width (estimate ~50 bars for typical barcode)
                            const estimatedBars = 50;
                            const widthPerBar = Math.max(1, barcodeWidth / estimatedBars);
                            
                            // Set explicit SVG dimensions
                            sv.setAttribute('width', barcodeWidth.toString());
                            sv.setAttribute('height', pxHeight.toString());
                            sv.setAttribute('viewBox', `0 0 ${barcodeWidth} ${pxHeight}`);
                            sv.setAttribute('preserveAspectRatio', 'none'); // No aspect ratio preservation - fill completely
                            
                            // Generate barcode with prefix + code + suffix included
                            JsBarcode(sv, barcodeValue, {
                                format: el.props.format || "CODE128",
                                displayValue: el.props.displayValue !== false,
                                width: widthPerBar,
                                height: pxHeight,
                                margin: 0
                            });
                        }catch(err){
                            sv.innerHTML = `<text x="10" y="20" fill="red" font-size="12">Invalid barcode</text>`;
                        }
                        break;
                    }
                    case 'image': {
                        const img = document.createElement('img');
                        img.style.pointerEvents='none';
                        img.style.width='100%';
                        img.style.height='100%';
                        img.style.objectFit = el.props.objectFit || 'contain';
                        if(el.props.boundColumn && R && Object.prototype.hasOwnProperty.call(R, el.props.boundColumn)){
                            const imgurId = R[el.props.boundColumn];
                            if(imgurId){
                                const id = String(imgurId).trim();
                                if(id){
                                    if(id.startsWith('http://') || id.startsWith('https://')){
                                        img.src = id;
                                    } else {
                                        const cleanId = id.replace(/\.(jpg|jpeg|png|gif|webp)$/i, '');
                                        img.src = `https://i.imgur.com/${cleanId}.jpg`;
                                    }
                                }
                            }
                        }
                        d.appendChild(img);
                        break;
                    }
                }
                
                page.appendChild(d);
            });
            
            return page;
        }
        
        // Add print container to DOM first so measurements work correctly
        document.body.appendChild(printContainer);
        
        // Add canvas 1 with specified sequence index
        const isLastPage1 = !canvas2Flag;
        const page1 = renderCanvasToPage(1, sequenceIndex, isLastPage1);
        printContainer.appendChild(page1);
        
        // Add canvas 2 if enabled with same sequence index
        if(canvas2Flag){
            const page2 = renderCanvasToPage(2, sequenceIndex, true);
            printContainer.appendChild(page2);
        }
        
        // Apply text overflow handling after all elements are in DOM
        const canvas1Data = design.canvas1 || [];
        const canvas2Data = design.canvas2 || [];
        const allPages = printContainer.querySelectorAll('.print-page');
        allPages.forEach((page, pageIndex) => {
            const canvasNum = (pageIndex === 0) ? 1 : 2;
            const canvasData = canvasNum === 1 ? canvas1Data : canvas2Data;
            const tempS = canvasData.map(normalizeElement);
            const sorted = tempS.slice().sort((a,b)=> (a.zIndex||0) - (b.zIndex||0));
            
            page.querySelectorAll('.label-element').forEach((d, index) => {
                if(index < sorted.length){
                    const el = sorted[index];
                    if((el.type === 'text' || el.type === 'data') && (el.props.textOverflow === 'auto-scale' || el.props.textOverflow === 'squeeze')){
                        const span = d.querySelector('div[style*="pointer-events: none"]');
                        if(span){
                            // Use real browser dimensions
                            const containerWidth = d.offsetWidth;
                            const containerHeight = d.offsetHeight;
                            applyTextOverflow(span, el, containerWidth, containerHeight, true);
                        }
                    }
                }
            });
        });
        
        // Wait for all images to load before printing
        const allImages = printContainer.querySelectorAll('img');
        const imagePromises = Array.from(allImages).map(img => {
            // If image is already loaded (complete), resolve immediately
            if(img.complete && img.naturalWidth > 0){
                return Promise.resolve();
            }
            // Otherwise wait for load or error
            return new Promise((resolve) => {
                img.onload = resolve;
                img.onerror = resolve; // Resolve even on error so print can proceed
                // Timeout after 5 seconds to prevent hanging
                setTimeout(resolve, 5000);
            });
        });
        
        // Wait for all images, then proceed with print
        Promise.all(imagePromises).then(() => {
            // Update print CSS for multiple pages (identical to printBothCanvases)
            const styleId = 'dynamic-print-css';
            let styleEl = document.getElementById(styleId);
            if(!styleEl){
                styleEl = document.createElement('style');
                styleEl.id = styleId;
                document.head.appendChild(styleEl);
            }
            styleEl.textContent = `
                @media print{
                    @page{size:${profile.width}cm ${profile.height}cm;margin:0}
                    html,body{margin:0!important;padding:0!important;background:#fff!important;width:${profile.width}cm!important;height:auto!important}
                    #toolbar,#sidebar,#marquee,.status-message{display:none!important}
                    .print-page{width:${profile.width}cm!important;height:${profile.height}cm!important;page-break-inside:avoid!important;overflow:visible!important;background:#fff!important;position:relative!important;margin:0!important;padding:0!important;display:block!important;box-sizing:border-box!important}
                    .print-page:not(:last-child){page-break-after:always!important}
                    .print-page:last-child{page-break-after:auto!important}
                    .print-container{display:block!important;position:static!important;left:auto!important;top:auto!important}
                    #main-content,#canvas-container,#canvas-wrapper,#label-canvas{display:none!important}
                    .label-element{print-color-adjust:exact!important;-webkit-print-color-adjust:exact!important}
                }
            `;
            
            // Print
            window.print();
            
            // Restore state after a delay
            setTimeout(()=>{
                currentCanvas = prevCanvas;
                S = prevS;
                selectedIds = prevSel;
                render();
                updateProps();
                if(printContainer.parentNode){
                    document.body.removeChild(printContainer);
                }
                updatePrintCSS(); // Restore normal print CSS
            }, 100);
        });
        } catch(err) {
            console.error('Error in printSingle:', err);
            msg('Error: ' + (err.message || String(err)), true);
            // Restore state on error if available
            if(typeof prevCanvas !== 'undefined') currentCanvas = prevCanvas;
            if(typeof prevS !== 'undefined') S = prevS;
            if(typeof prevSel !== 'undefined') selectedIds = prevSel;
            render();
            updateProps();
        }
    }

    // ---------- Mouse interactions: marquee, selection, drag, resize ----------
        // Allow starting marquee selection from outside the canvas
        function startMarqueeSelection(e){
            // start marquee - compute coordinates relative to canvas-container (so zoom & transform do not misplace)
            const containerRect = cc.getBoundingClientRect();
            marqueeActive = true;
            marqueeStart.clientX = e.clientX;
            marqueeStart.clientY = e.clientY;
            // startX/startY in pixels relative to container
            marqueeStart.startX = e.clientX - containerRect.left;
            marqueeStart.startY = e.clientY - containerRect.top;
            marqueeStart.containerRect = containerRect;
            marquee.style.display = 'block';
            marquee.style.left = `${marqueeStart.startX}px`;
            marquee.style.top = `${marqueeStart.startY}px`;
            marquee.style.width = '0px';
            marquee.style.height = '0px';
            e.preventDefault();
        }

        // Listen for mousedown on canvas-container (allows starting from outside canvas)
        cc.addEventListener('mousedown', (e)=>{
            // Disabilita interazioni quando non √® in full screen
            if (!isFullScreen) return;
            
            // Assicura che il focus sia sul canvas container quando si clicca sul canvas
            // Rimuovi il focus da qualsiasi elemento della sidebar
            const sidebar = document.getElementById('sidebar');
            if(sidebar){
                const focusedElement = sidebar.querySelector(':focus');
                if(focusedElement){
                    focusedElement.blur();
                }
            }
            
            if (cc.tabIndex === -1) {
                cc.setAttribute('tabindex', '-1');
            }
            // Usa setTimeout per assicurarsi che il blur della sidebar avvenga prima
            setTimeout(() => {
                cc.focus();
            }, 0);
            
            const t = e.target;
            // If clicking on the background (container or canvas), start marquee selection
            if(t === cc || t === lc){
                startMarqueeSelection(e);
                return;
            }
        });

        lc.addEventListener('mousedown', (e)=>{
            // Disabilita interazioni quando non √® in full screen
            if (!isFullScreen) return;
                
                // Assicura che il focus sia sul canvas container quando si clicca sul canvas
                // Rimuovi il focus da qualsiasi elemento della sidebar
                const sidebar = document.getElementById('sidebar');
                if(sidebar){
                    const focusedElement = sidebar.querySelector(':focus');
                    if(focusedElement){
                        focusedElement.blur();
                    }
                }
                
                if (cc.tabIndex === -1) {
                    cc.setAttribute('tabindex', '-1');
                }
                // Usa setTimeout per assicurarsi che il blur della sidebar avvenga prima
                setTimeout(() => {
                    cc.focus();
                }, 0);
            
            const t = e.target;
            // If clicking on the background of label-canvas, start marquee selection
            if(t === lc){
                startMarqueeSelection(e);
            return;
        }

        // clicked element
        const te = t.closest('.label-element');
        if(!te) return;
        const id = te.dataset.id;
        const clickedElement = S.find(x=>x.id===id);
        if(!clickedElement) return;

        // selection logic
        if(e.ctrlKey || e.metaKey){
            pushBeforeChange();
            toggleSelection(id);
        } else {
            if(!selectedIds.includes(id)){
                pushBeforeChange();
                    // If element is in a group, select all elements in the group
                    const group = getGroupForElement(id);
                    if(group){
                        setSelection(group.elementIds);
                    } else {
                setSelection([id]);
                    }
            }
        }

        const cr = lc.getBoundingClientRect();
        const smx = (e.clientX - cr.left) / cr.width * W;
        const smy = (e.clientY - cr.top) / cr.height * H;

            // Check if clicked element is in a group
            const group = getGroupForElement(id);
            const isGrouped = group !== undefined;
            
            // Check if clicked on resize handle (including inner element)
            const resizeHandle = t.classList.contains('resize-handle') ? t : t.closest('.resize-handle');
            if(resizeHandle){
                if(isGrouped){
                    // Resize group - check if all group elements are selected or just this one
                    const allGroupSelected = group.elementIds.every(eid => selectedIds.includes(eid));
                    if(allGroupSelected || (selectedIds.length === 1 && selectedIds[0] === id)){
            resizeMode = true;
                        const groupBounds = getGroupBounds(group.elementIds);
                        // Store original element positions, sizes, and properties for scaling
                        const originalElements = {};
                        group.elementIds.forEach(elementId => {
                            const el = S.find(e => e.id === elementId);
                            if(el){
                                originalElements[elementId] = {
                                    x: el.x,
                                    y: el.y,
                                    width: el.width,
                                    height: el.height,
                                    props: deepCopy(el.props)
                                };
                            }
                        });
                        ctx = { 
                            isGroup: true,
                            groupId: group.id,
                            group: group,
                            startWidth: groupBounds.width,
                            startHeight: groupBounds.height,
                            startMouseX: smx,
                            startMouseY: smy,
                            originalBounds: {...groupBounds},
                            originalElements: originalElements
                        };
                    }
                } else if(!isGrouped && selectedIds.length <= 1){
                    resizeMode = true;
                    ctx = { el: clickedElement, startWidth: clickedElement.width, startHeight: clickedElement.height, startMouseX: smx, startMouseY: smy, isGroup: false };
                }
            }
            
            if(!resizeMode){
            drag = true;
                if(isGrouped){
                    // Move entire group
                    const groupElementIds = group.elementIds;
                    const items = groupElementIds.map(iid => S.find(s => s.id === iid)).filter(Boolean);
                    ctx = { 
                        items: items.map(it => ({ id: it.id, startX: it.x, startY: it.y })), 
                        baseMouseX: smx, 
                        baseMouseY: smy,
                        isGroup: true,
                        groupId: group.id
                    };
                } else {
                    // Move individual elements
            const movers = selectedIds.includes(id) ? selectedIds.slice() : [id];
            const items = movers.map(iid => S.find(s => s.id === iid)).filter(Boolean);
                    ctx = { items: items.map(it => ({ id: it.id, startX: it.x, startY: it.y })), baseMouseX: smx, baseMouseY: smy, isGroup: false };
                }
            pushBeforeChange();
        }
        e.preventDefault();
    });

    window.addEventListener('mousemove', (e)=>{
            // Disabilita interazioni quando non √® in full screen
            if (!isFullScreen && (drag || resizeMode || marqueeActive)) {
                drag = false;
                resizeMode = false;
                marqueeActive = false;
                marquee.style.display = 'none';
                return;
            }
            
        // marquee active handling: draw marquee relative to container (so zoom/transform doesn't misplace)
        if(marqueeActive){
            const containerRect = marqueeStart.containerRect || cc.getBoundingClientRect();
            const curX = e.clientX - containerRect.left;
            const curY = e.clientY - containerRect.top;
            const left = Math.min(marqueeStart.startX, curX);
            const top = Math.min(marqueeStart.startY, curY);
            const width = Math.abs(curX - marqueeStart.startX);
            const height = Math.abs(curY - marqueeStart.startY);
            marquee.style.left = `${left}px`;
            marquee.style.top = `${top}px`;
            marquee.style.width = `${width}px`;
            marquee.style.height = `${height}px`;
            return;
        }

        if(!drag && !resizeMode) return;
        const cr = lc.getBoundingClientRect();
        const mx = (e.clientX - cr.left) / cr.width * W;
        const my = (e.clientY - cr.top) / cr.height * H;

        if(drag && ctx && ctx.items){
            const dx = mx - ctx.baseMouseX;
            const dy = my - ctx.baseMouseY;
            ctx.items.forEach(it=>{
                const el = S.find(s=>s.id===it.id);
                if(!el) return;
                    // Calculate new position
                    let newX = it.startX + dx;
                    let newY = it.startY + dy;
                    
                    // Get effective bounds considering rotation
                    const bounds = getRotatedBounds(el);
                    const effectiveWidth = bounds.width;
                    const effectiveHeight = bounds.height;
                    
                    // Constrain to canvas bounds considering rotation
                    // The element center should stay within bounds
                    const centerX = newX + el.width / 2;
                    const centerY = newY + el.height / 2;
                    
                    // Adjust position to keep rotated bounding box within canvas
                    newX = Math.max((effectiveWidth - el.width) / 2, Math.min(newX, W - (effectiveWidth + el.width) / 2));
                    newY = Math.max((effectiveHeight - el.height) / 2, Math.min(newY, H - (effectiveHeight + el.height) / 2));
                    
                        // Snap to pixel precision
                        el.x = snapToPixel(newX);
                        el.y = snapToPixel(newY);
            });
            render();
            updateProps();
            } else if(resizeMode && ctx){
                if(ctx.isGroup && ctx.group){
                    // Resize group maintaining proportions
                    const dx = mx - ctx.startMouseX;
                    const dy = my - ctx.startMouseY;
                    
                    // Calculate scale based on diagonal distance to maintain aspect ratio
                    const originalBounds = ctx.originalBounds;
                    const diagonal = Math.sqrt(originalBounds.width * originalBounds.width + originalBounds.height * originalBounds.height);
                    const newDiagonal = Math.sqrt((originalBounds.width + dx) * (originalBounds.width + dx) + (originalBounds.height + dy) * (originalBounds.height + dy));
                    let scale = newDiagonal / diagonal;
                    
                    // Ensure minimum scale
                    scale = Math.max(0.1, scale);
                    
                    // Constrain to canvas - check if scaled group fits
                    const newWidth = originalBounds.width * scale;
                    const newHeight = originalBounds.height * scale;
                    const maxWidth = W - originalBounds.x;
                    const maxHeight = H - originalBounds.y;
                    
                    // Limit scale to fit within canvas
                    if(newWidth > maxWidth) scale = Math.min(scale, maxWidth / originalBounds.width);
                    if(newHeight > maxHeight) scale = Math.min(scale, maxHeight / originalBounds.height);
                    
                    // Apply uniform scaling to all elements in group (including properties)
                    ctx.group.elementIds.forEach(elementId => {
                        const el = S.find(e => e.id === elementId);
                        if(!el) return;
                        
                        // Store original values if not already stored
                        if(!ctx.originalElements){
                            ctx.originalElements = {};
                        }
                        if(!ctx.originalElements[elementId]){
                            ctx.originalElements[elementId] = {
                                x: el.x,
                                y: el.y,
                                width: el.width,
                                height: el.height,
                                props: deepCopy(el.props)
                            };
                        }
                        
                        const orig = ctx.originalElements[elementId];
                        
                        // Calculate relative position from group origin
                        const relX = orig.x - originalBounds.x;
                        const relY = orig.y - originalBounds.y;
                        
                        // Scale position and size uniformly (snapped to pixel precision)
                        el.x = snapToPixel(originalBounds.x + relX * scale);
                        el.y = snapToPixel(originalBounds.y + relY * scale);
                        el.width = snapToPixel(orig.width * scale);
                        el.height = snapToPixel(orig.height * scale);
                        
                        // Scale all size-related properties proportionally (rounded to 1 decimal)
                        if(el.props){
                            // Font size
                            if(orig.props.fontSize !== undefined){
                                el.props.fontSize = Math.round(Math.max(6, orig.props.fontSize * scale) * 10) / 10;
                            }
                            // Padding
                            if(orig.props.paddingTop !== undefined) el.props.paddingTop = Math.round(orig.props.paddingTop * scale * 10) / 10;
                            if(orig.props.paddingRight !== undefined) el.props.paddingRight = Math.round(orig.props.paddingRight * scale * 10) / 10;
                            if(orig.props.paddingBottom !== undefined) el.props.paddingBottom = Math.round(orig.props.paddingBottom * scale * 10) / 10;
                            if(orig.props.paddingLeft !== undefined) el.props.paddingLeft = Math.round(orig.props.paddingLeft * scale * 10) / 10;
                            // Border width
                            if(orig.props.borderWidth !== undefined) el.props.borderWidth = Math.round(Math.max(0.1, orig.props.borderWidth * scale) * 10) / 10;
                            // Thickness (for lines and boxes)
                            if(orig.props.thickness !== undefined) el.props.thickness = Math.round(Math.max(0.1, orig.props.thickness * scale) * 10) / 10;
                            // Border radius
                            if(orig.props.borderRadiusTopLeft !== undefined) el.props.borderRadiusTopLeft = Math.round(orig.props.borderRadiusTopLeft * scale * 10) / 10;
                            if(orig.props.borderRadiusTopRight !== undefined) el.props.borderRadiusTopRight = Math.round(orig.props.borderRadiusTopRight * scale * 10) / 10;
                            if(orig.props.borderRadiusBottomRight !== undefined) el.props.borderRadiusBottomRight = Math.round(orig.props.borderRadiusBottomRight * scale * 10) / 10;
                            if(orig.props.borderRadiusBottomLeft !== undefined) el.props.borderRadiusBottomLeft = Math.round(orig.props.borderRadiusBottomLeft * scale * 10) / 10;
                        }
                    });
                    
                    // Update group bounds
                    ctx.group.bounds = getGroupBounds(ctx.group.elementIds);
                } else if(ctx.el){
            const dx = mx - ctx.startMouseX;
            const dy = my - ctx.startMouseY;
            let nw = ctx.startWidth + dx;
            let nh = ctx.startHeight + dy;
                
                // Get current rotation
                const rotation = Number(ctx.el.props.rotation) || 0;
                const bounds = getRotatedBounds({ width: nw, height: nh, props: { rotation: rotation } });
                
                // Constrain resize considering rotation
                const maxWidth = W - ctx.el.x;
                const maxHeight = H - ctx.el.y;
                
                // For rotated elements, we need to check if the rotated bounding box fits
                        let finalWidth, finalHeight;
                if(rotation === 0 || rotation === 180 || rotation === -180){
                            finalWidth = Math.max(.2, Math.min(nw, maxWidth));
                            finalHeight = Math.max(.2, Math.min(nh, maxHeight));
                } else if(rotation === 90 || rotation === -90 || rotation === 270 || rotation === -270){
                    // When rotated 90¬∞, width and height are swapped
                            finalWidth = Math.max(.2, Math.min(nw, maxWidth));
                            finalHeight = Math.max(.2, Math.min(nh, maxHeight));
                    // Check if rotated bounding box fits
                            if(finalHeight > maxWidth) finalHeight = maxWidth;
                            if(finalWidth > maxHeight) finalWidth = maxHeight;
                } else {
                    // For other angles, use the rotated bounds
                            finalWidth = Math.max(.2, nw);
                            finalHeight = Math.max(.2, nh);
                    // Check if rotated bounding box fits
                    if(bounds.width > W - ctx.el.x) {
                        const scale = (W - ctx.el.x) / bounds.width;
                                finalWidth *= scale;
                                finalHeight *= scale;
                    }
                    if(bounds.height > H - ctx.el.y) {
                        const scale = (H - ctx.el.y) / bounds.height;
                                finalWidth *= scale;
                                finalHeight *= scale;
                    }
                        }
                        // Snap to pixel precision
                        ctx.el.width = snapToPixel(finalWidth);
                        ctx.el.height = snapToPixel(finalHeight);
                }
            render();
            updateProps();
        }
    });

    window.addEventListener('mouseup', (e)=>{
            // Disabilita interazioni quando non √® in full screen
            if (!isFullScreen) {
                drag = false;
                resizeMode = false;
                marqueeActive = false;
                marquee.style.display = 'none';
                return;
                }
                
            if(drag && ctx && ctx.items){
                // Update group bounds after drag if it was a group
                if(ctx.isGroup && ctx.groupId){
                    const group = groups.find(g => g.id === ctx.groupId);
                    if(group){
                        group.bounds = getGroupBounds(group.elementIds);
                    }
                }
            }
            if(resizeMode && ctx && ctx.isGroup && ctx.group){
                // Update group bounds after resize
                ctx.group.bounds = getGroupBounds(ctx.group.elementIds);
            }
            
        if(marqueeActive){
            // compute selection rectangle intersection using label-canvas bounding rect (this respects zoom)
            const rect = lc.getBoundingClientRect();
            const x1 = marqueeStart.clientX, y1 = marqueeStart.clientY;
            const x2 = e.clientX, y2 = e.clientY;
            // determine screen-space selection bounds
            const leftPx = Math.min(x1,x2);
            const topPx = Math.min(y1,y2);
            const rightPx = Math.max(x1,x2);
            const bottomPx = Math.max(y1,y2);
            // clamp to label-canvas
            const selLeft = Math.max(leftPx, rect.left);
            const selTop = Math.max(topPx, rect.top);
            const selRight = Math.min(rightPx, rect.right);
            const selBottom = Math.min(bottomPx, rect.bottom);

            let selected = [];
            if(selRight > selLeft && selBottom > selTop){
                const fracLeft = (selLeft - rect.left) / rect.width;
                const fracTop = (selTop - rect.top) / rect.height;
                const fracRight = (selRight - rect.left) / rect.width;
                const fracBottom = (selBottom - rect.top) / rect.height;
                const cmLeft = fracLeft * W;
                const cmTop = fracTop * H;
                const cmRight = fracRight * W;
                const cmBottom = fracBottom * H;

                // select elements whose rectangles intersect the selection rect
                S.forEach(el=>{
                    const elLeft = el.x;
                    const elTop = el.y;
                    const elRight = el.x + el.width;
                    const elBottom = el.y + el.height;
                    const intersect = !(elRight < cmLeft || elLeft > cmRight || elBottom < cmTop || elTop > cmBottom);
                    if(intersect) selected.push(el.id);
                });
            }

            // ctrl/meta -> toggle behavior; otherwise replace selection
            if(e.ctrlKey || e.metaKey){
                selected.forEach(id=>{
                    const i = selectedIds.indexOf(id);
                    if(i===-1) selectedIds.push(id); else selectedIds.splice(i,1);
                });
            } else {
                selectedIds = selected;
            }

            marqueeActive = false;
            marquee.style.display = 'none';
            render();
            updateProps();
            updateBtns();
                saveCurrentDesign();
            e.preventDefault();
            return;
        }

        if(drag || resizeMode){
                saveCurrentDesign();
        }
        drag = false; resizeMode = false; ctx = {};
    });

    // ---------- Keyboard shortcuts (undo/redo/multi) ----------
    window.addEventListener('keydown', (e)=>{
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z'){
            e.preventDefault();
            if(e.shiftKey) redo(); else undo();
            return;
        }
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y'){
            e.preventDefault(); redo(); return;
        }

        if((e.key === 'Delete' || e.key === 'Backspace') && selectedIds.length>0){
            if(e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA'){ e.preventDefault(); deleteSelected(); }
        }

            // Ignore arrow keys if user is typing in an input/select/textarea
            const activeElement = document.activeElement;
            if(activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')){
                // Allow arrow keys in select elements for font navigation (handled separately)
                if(activeElement.tagName === 'SELECT' && (activeElement.id && (activeElement.id.includes('font-family-select') || activeElement.id.includes('multi-font-family-select')))){
                    // Font select navigation is handled in its own listener, but we still want to prevent element movement
                    return;
                }
                // For textarea, allow all normal typing including "." - don't interfere
                if(activeElement.tagName === 'TEXTAREA'){
                    return;
                }
                // For other inputs/selects, don't move elements
                return;
            }

        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
                    // Only handle arrow keys in full screen mode
                    if (!isFullScreen) return;
                    
                // Don't move elements if user is interacting with form controls
                // Exception: allow font select navigation (handled separately with stopPropagation)
                if(e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT'){
                if(selectedIds.length>0){
                    e.preventDefault();
                        // Convert step from pixels to cm (1cm = 37.795276px at 96 DPI)
                        // Use 1 pixel for normal step, 5 pixels for shift+arrow
                        const pixelsPerCm = 37.795276;
                        const stepPixels = e.shiftKey ? 5 : 1;
                        const step = stepPixels / pixelsPerCm;
                    pushBeforeChange();
                    selectedIds.forEach(id=>{
                        const el = S.find(s=>s.id===id); if(!el) return;
                            // Get effective bounds considering rotation
                            const bounds = getRotatedBounds(el);
                            const effectiveWidth = bounds.width;
                            const effectiveHeight = bounds.height;
                            
                        switch(e.key){
                                case 'ArrowUp': {
                                    const newY = el.y - step;
                                    el.y = snapToPixel(Math.max((effectiveHeight - el.height) / 2, newY));
                                    break;
                                }
                                case 'ArrowDown': {
                                    const newY = el.y + step;
                                    el.y = snapToPixel(Math.min(H - (effectiveHeight + el.height) / 2, newY));
                                    break;
                                }
                                case 'ArrowLeft': {
                                    const newX = el.x - step;
                                    el.x = snapToPixel(Math.max((effectiveWidth - el.width) / 2, newX));
                                    break;
                                }
                                case 'ArrowRight': {
                                    const newX = el.x + step;
                                    el.x = snapToPixel(Math.min(W - (effectiveWidth + el.width) / 2, newX));
                                    break;
                                }
                            }
                        });
                        render(); updateProps(); saveCurrentDesign();
                }
            }
        }

        if((e.ctrlKey||e.metaKey) && e.key.toLowerCase() === 'd'){
            e.preventDefault();
            dupSelected();
        }

            // Group/Ungroup shortcuts
            if((e.ctrlKey||e.metaKey) && e.key.toLowerCase() === 'g'){
                e.preventDefault();
                if(e.shiftKey){
                    ungroupSelected();
                } else {
                    groupSelected();
                }
        }
    });

    // ---------- Property edits (apply to single or multiple) ----------
    pp.addEventListener('input', (e)=>{
        if(selectedIds.length === 0 && e.target.dataset.prop !== 'bind_search') return;
            
            // Block property edits if any selected element is in a group
            const hasGroupedElement = selectedIds.some(id => getGroupForElement(id) !== undefined);
            if(hasGroupedElement){
                e.preventDefault();
                e.stopPropagation();
                msg('Cannot edit properties of grouped elements. Ungroup first (Ctrl+Shift+G).');
                return;
            }
        const target = e.target;
        const prop = target.dataset.prop;
        if(!prop) return;

        // Handle bound column search input
        if(prop === 'bind_search'){
                // Clear previous debounce timer
                if(searchDebounceTimer) clearTimeout(searchDebounceTimer);
                
                const query = String(target.value || '').trim();
            const select = pp.querySelector('select[data-prop="props.boundColumn"]');
            if(!select) return;
                
                // Debounce search for better performance
                searchDebounceTimer = setTimeout(() => {
                    if(!query){
                        // No query - show all columns
                        select.innerHTML = `<option value="">-- Select Column --</option>${C.map(col => `<option value="${col}" ${select.value===col?'selected':''}>${col}</option>`).join('')}`;
                    } else {
                        // Use improved search
                        const results = searchColumns(query, C);
                        if(results.length === 0){
                            select.innerHTML = `<option value="">-- No matches found --</option>`;
                        } else {
                            select.innerHTML = `<option value="">-- Select Column (${results.length} found) --</option>${results.map(({col}) => `<option value="${col}" ${select.value===col?'selected':''}>${col}</option>`).join('')}`;
                        }
                    }
                }, 150); // 150ms debounce
            return;
        }

        if(prop.startsWith('multi.')){
            const keyPath = prop.slice('multi.'.length);
            
            // Special handling for x, y, width, height when input is empty (indeterminate state)
            // Allow spinner to increment/decrement all values by 1
            if(['x', 'y', 'width', 'height'].includes(keyPath) && target.type === 'number'){
                const previousValue = target.dataset.previousValue || '';
                const currentValue = target.value;
                
                // Check if input was empty and now has a value (spinner was used)
                if((previousValue === '' || previousValue === null || previousValue === undefined || isNaN(previousValue)) && 
                   currentValue !== '' && !isNaN(currentValue)){
                    
                    // Get all selected elements
                    const elements = selectedIds.map(id => S.find(e => e.id === id)).filter(Boolean);
                    if(elements.length === 0) return;
                    
                    // Determine if increment or decrement based on the new value
                    // Compare with first element's current value
                    const firstVal = elements[0][keyPath] || 0;
                    const newVal = Number(currentValue);
                    const step = Number(target.step) || 0.01;
                    
                    // Check if this looks like a spinner action (value changed by step amount)
                    const diff = newVal - firstVal;
                    const absDiff = Math.abs(diff);
                    
                    // If the difference is small (within 2 steps), treat as spinner action
                    if(absDiff <= step * 2){
                        e.preventDefault();
                        e.stopPropagation();
                        
                        pushBeforeChange();
                        
                        // Convert 1 pixel to cm (1 pixel = 1/37.795276 cm)
                        const onePixelInCm = 1 / PIXELS_PER_CM;
                        // Determine direction: if newVal > firstVal, increment; otherwise decrement
                        const delta = diff > 0 ? onePixelInCm : -onePixelInCm;
                        
                        elements.forEach(el => {
                            const currentVal = el[keyPath] || 0;
                            const updatedVal = currentVal + delta;
                            el[keyPath] = snapToPixel(updatedVal);
                        });
                        
                        render();
                        updateProps();
                        saveCurrentDesign();
                        return;
                    }
                }
                
                // Store current value for next comparison
                target.dataset.previousValue = currentValue;
            }
            
            const value = (target.type === 'checkbox') ? target.checked : (target.type === 'number' ? Number(target.value) : target.value);
                
                // Special handling: when showBorder is enabled, activate all border sides
                if(keyPath === 'props.showBorder' && value === true){
                    pushBeforeChange();
                    selectedIds.forEach(id=>{
                        const el = S.find(s=>s.id===id);
                        if(!el) return;
                        el.props.showBorder = true;
                        el.props.borderTop = true;
                        el.props.borderRight = true;
                        el.props.borderBottom = true;
                        el.props.borderLeft = true;
                    });
                    render(); updateProps(); saveCurrentDesign();
                    return;
                }
                
            pushBeforeChange();
            selectedIds.forEach(id=>{
                const el = S.find(s=>s.id===id);
                if(!el) return;
                if(keyPath.includes('.')){
                    const [o,k] = keyPath.split('.');
                    if(!el[o]) el[o] = {};
                        if(['fontSize','lineHeight','decimals','thickness','borderWidth','rotation','paddingTop','paddingRight','paddingBottom','paddingLeft','x','y','width','height'].includes(k)) el[o][k] = Number(value);
                        else if(['showBorder','displayValue','asPercent','borderTop','borderRight','borderBottom','borderLeft'].includes(k)) el[o][k] = !!value;
                        else if(k === 'fontWeight'){
                            // Handle fontWeight: can be number (100-900) or string ('normal', 'bold')
                            const numVal = Number(value);
                            el[o][k] = (!isNaN(numVal) && numVal >= 100 && numVal <= 900) ? numVal : value;
                        }
                    else el[o][k] = value;
                } else {
                    if(['x','y','width','height','zIndex'].includes(keyPath)) el[keyPath] = Number(value);
                    else el[keyPath] = value;
                }
            });
                render(); updateProps(); saveCurrentDesign();
            return;
        }

        const applyToAll = selectedIds.length > 1;
        const parsedValue = (target.type === 'checkbox') ? target.checked : (target.type === 'number' ? Number(target.value) : target.value);
            
            // Special handling: when showBorder is enabled, activate all border sides
            if(prop === 'props.showBorder' && parsedValue === true){
                pushBeforeChange();
                if(applyToAll){
                    selectedIds.forEach(id=>{
                        const el = S.find(s=>s.id===id); if(!el) return;
                        el.props.showBorder = true;
                        el.props.borderTop = true;
                        el.props.borderRight = true;
                        el.props.borderBottom = true;
                        el.props.borderLeft = true;
                    });
                } else {
                    const id = selectedIds[0];
                    const el = S.find(s=>s.id===id);
                    if(el) {
                        el.props.showBorder = true;
                        el.props.borderTop = true;
                        el.props.borderRight = true;
                        el.props.borderBottom = true;
                        el.props.borderLeft = true;
                    }
                }
                render(); 
                updateProps(); 
                saveCurrentDesign();
                return;
            }

        function applyPropToElement(el, p, v){
            if(p === 'widthHeight'){ el.height = Number(v); return; }
            if(p.includes('.')){
                const [o,k] = p.split('.');
                if(!el[o]) el[o] = {};
                    if(['fontSize','decimals','thickness','borderWidth','rotation','paddingTop','paddingRight','paddingBottom','paddingLeft','x','y','width','height','borderRadiusTopLeft','borderRadiusTopRight','borderRadiusBottomRight','borderRadiusBottomLeft'].includes(k)) el[o][k] = Number(v);
                    else if(['showBorder','displayValue','asPercent','borderTop','borderRight','borderBottom','borderLeft'].includes(k)) el[o][k] = !!v;
                    else if(k === 'fontWeight'){
                        // Handle fontWeight: can be number (100-900) or string ('normal', 'bold')
                        const numVal = Number(v);
                        el[o][k] = (!isNaN(numVal) && numVal >= 100 && numVal <= 900) ? numVal : v;
                    }
                else el[o][k] = v;
            } else {
                if(['x','y','width','height','zIndex'].includes(p)) el[p] = Number(v);
                else el[p] = v;
            }
        }

        pushBeforeChange();
        if(applyToAll){
            selectedIds.forEach(id=>{
                const el = S.find(s=>s.id===id); if(!el) return;
                applyPropToElement(el, prop, parsedValue);
            });
        } else {
            const id = selectedIds[0];
            const el = S.find(s=>s.id===id);
            if(el) applyPropToElement(el, prop, parsedValue);
        }
            render(); 
            saveCurrentDesign(); 
            saveCurrentDesign();
    });

    pp.addEventListener('click', (e)=>{
        if(e.target && e.target.id === 'btn-delete'){
            deleteSelected();
        }
    });

        // ---------- Prevent textarea from losing focus when typing "." ----------
        // Add listener to textarea to prevent focus loss
        pp.addEventListener('keydown', (e)=>{
            // If user is typing in a textarea, prevent any behavior that might cause focus loss
            if(e.target.tagName === 'TEXTAREA'){
                // Stop propagation to prevent any parent handlers from interfering
                e.stopPropagation();
                // Allow all normal text input, including "." character
                // Don't prevent default for normal typing
                return;
            }
        }, true);
        
        // Also prevent any click events on the canvas while typing in textarea
        pp.addEventListener('mousedown', (e)=>{
            // If user is typing in a textarea, don't let clicks outside interfere
            if(e.target.tagName === 'TEXTAREA'){
                e.stopPropagation();
            }
        }, true);
        
        // Prevent canvas clicks from stealing focus from textarea
        lc.addEventListener('mousedown', (e)=>{
            // If a textarea is focused, don't let canvas clicks steal focus
            const activeElement = document.activeElement;
            if(activeElement && activeElement.tagName === 'TEXTAREA'){
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }, true);

        // ---------- Continuous increment for number inputs (spinner hold) ----------
        let spinnerInterval = null;
        let spinnerDirection = null;
        let spinnerInput = null;
        let spinnerStep = null;
        let spinnerMin = null;
        let spinnerMax = null;
        
        pp.addEventListener('mousedown', (e)=>{
            const target = e.target;
            if(target.type !== 'number' || !target.dataset.prop) return;
            
            // Check if click is on the spinner (right side of input)
            const rect = target.getBoundingClientRect();
            const clickX = e.clientX;
            const isOnSpinner = clickX > rect.right - 20; // Spinner is typically ~20px wide
            
            if(!isOnSpinner) return;
            
            // Determine direction based on which part of spinner was clicked
            const spinnerHeight = rect.height;
            const clickY = e.clientY - rect.top;
            const isUpButton = clickY < spinnerHeight / 2;
            
            spinnerInput = target;
            spinnerDirection = isUpButton ? 1 : -1;
            
            // Get step value from input or default to 0.01
            spinnerStep = parseFloat(target.step) || 0.01;
            spinnerMin = target.min !== '' ? parseFloat(target.min) : null;
            spinnerMax = target.max !== '' ? parseFloat(target.max) : null;
            
            // Determine decimal places based on step
            const stepStr = String(spinnerStep);
            const decimalPlaces = stepStr.includes('.') ? stepStr.split('.')[1].length : 0;
            
            // Initial increment/decrement
            let currentValue = parseFloat(target.value) || 0;
            currentValue += spinnerDirection * spinnerStep;
            if(spinnerMin !== null && currentValue < spinnerMin) currentValue = spinnerMin;
            if(spinnerMax !== null && currentValue > spinnerMax) currentValue = spinnerMax;
            
            // Format value based on step (integers for step=1, decimals for step=0.01)
            if(decimalPlaces > 0) {
                target.value = currentValue.toFixed(decimalPlaces);
            } else {
                target.value = Math.round(currentValue);
            }
            
            // Trigger input event to update the element
            target.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Start continuous increment after a short delay
            let delay = 500; // Initial delay before continuous increment starts
            spinnerInterval = setTimeout(() => {
                spinnerInterval = setInterval(() => {
                    // Read current value from input (in case it was updated by updateProps)
                    let currentValue = parseFloat(target.value) || 0;
                    currentValue += spinnerDirection * spinnerStep;
                    if(spinnerMin !== null && currentValue < spinnerMin) currentValue = spinnerMin;
                    if(spinnerMax !== null && currentValue > spinnerMax) currentValue = spinnerMax;
                    
                    // Format value based on step
                    if(decimalPlaces > 0) {
                        target.value = currentValue.toFixed(decimalPlaces);
                    } else {
                        target.value = Math.round(currentValue);
                    }
                    
                    // Trigger input event to update the element
                    target.dispatchEvent(new Event('input', { bubbles: true }));
                }, 50); // Fast increment rate
            }, delay);
            
            e.preventDefault();
        });
        
        window.addEventListener('mouseup', (e)=>{
            if(spinnerInterval){
                clearTimeout(spinnerInterval);
                spinnerInterval = null;
            }
            spinnerInput = null;
            spinnerDirection = null;
            spinnerStep = null;
            spinnerMin = null;
            spinnerMax = null;
        });

        // ---------- Canvas Rotation ----------
        function applyCanvasRotation(){
            // Applica la rotazione combinata con lo zoom esistente
            setZoom(z); // Questo ora combina rotazione e zoom
            
            // Aggiusta lo zoom dopo la rotazione per fittare il canvas
            setTimeout(() => {
                if (!isFullScreen) {
                    // In modalit√† widget, calcola lo zoom considerando la rotazione
                    const miniToolbar = document.getElementById('mini-toolbar');
                    const toolbarHeight = miniToolbar ? miniToolbar.offsetHeight : 0;
                    const availableHeight = window.innerHeight - toolbarHeight;
                    const availableWidth = window.innerWidth;
                    
                    // Quando ruotato di 90¬∞ o 270¬∞, le dimensioni effettive si scambiano
                    const effectiveWidth = (canvasRotation === 90 || canvasRotation === 270) ? H : W;
                    const effectiveHeight = (canvasRotation === 90 || canvasRotation === 270) ? W : H;
                    
                    const hw = (availableWidth - 40) / (effectiveWidth * 37.795276);
                    const vw = (availableHeight - 40) / (effectiveHeight * 37.795276);
                    setZoom(Math.min(hw, vw, 1.5));
                } else {
                    // In full screen, calcola lo zoom considerando la rotazione
                    const cr = cc.getBoundingClientRect();
                    // Quando ruotato di 90¬∞ o 270¬∞, le dimensioni effettive si scambiano
                    const effectiveWidth = (canvasRotation === 90 || canvasRotation === 270) ? H : W;
                    const effectiveHeight = (canvasRotation === 90 || canvasRotation === 270) ? W : H;
                    const hw = (cr.width - 40) / (effectiveWidth * 37.795276);
                    const vw = (cr.height - 40) / (effectiveHeight * 37.795276);
                    setZoom(Math.min(hw, vw, 1.5));
                }
            }, 50);
        }

        // ---------- Sidebar focus management ----------
        const sidebar = document.getElementById('sidebar');
        if(sidebar){
            // Remove focus from sidebar when clicking on empty area
            sidebar.addEventListener('mousedown', (e)=>{
                // Only remove focus if clicking on the sidebar itself (not on interactive elements)
                if(e.target === sidebar || e.target.classList.contains('sidebar-section')){
                    const focusedElement = sidebar.querySelector(':focus');
                    if(focusedElement){
                        focusedElement.blur();
                    }
                    // Set focus to canvas container instead
                    if(cc && isFullScreen){
                        if(cc.tabIndex === -1){
                            cc.setAttribute('tabindex', '-1');
                        }
                        setTimeout(() => {
                            cc.focus();
                        }, 0);
                    }
                }
            });
        }

        // ---------- Buttons ----------
    document.getElementById('btn-print').addEventListener('click', ()=>{
        printBothCanvases();
    });
    document.getElementById('btn-print-single').addEventListener('click', ()=>{
        printSingle();
    });
        document.getElementById('btn-rotate-canvas').addEventListener('click', ()=>{
            canvasRotation = (canvasRotation + 90) % 360;
            applyCanvasRotation();
    });
    document.getElementById('btn-clear').addEventListener('click', ()=>{
        if(confirm('Are you sure you want to clear the layout?')){
            pushBeforeChange();
            S=[]; selectedIds=[];
            render(); updateProps(); updateBtns();
                saveCurrentDesign();
                saveCurrentDesign();
        }
    });
    bd.addEventListener('click', dupSelected);
    bf.addEventListener('click', bringToFront);
    bs.addEventListener('click', sendToBack);
    document.getElementById('btn-zoom-in').addEventListener('click', ()=> setZoom(z*1.25));
    document.getElementById('btn-zoom-out').addEventListener('click', ()=> setZoom(z/1.25));
    document.getElementById('btn-zoom-fit').addEventListener('click', fit);

    document.querySelectorAll('.add-element').forEach(b=> b.addEventListener('click', e => add(e.currentTarget.dataset.type)));

    btnExport.addEventListener('click', ()=>{ exportToFile(); msg('Layout exported to file.'); });
    btnImport.addEventListener('click', ()=>{ fileInput.value=''; fileInput.click(); });

        // Profile/Design management
        profileSelector.addEventListener('change', (e)=>{
            switchProfile(e.target.value);
            saveCurrentDesign();
        });
        designSelector.addEventListener('change', (e)=>{
            switchDesign(e.target.value);
            saveCurrentDesign();
        });
        btnAddProfile.addEventListener('click', ()=>{
            addProfile();
        });
        btnAddDesign.addEventListener('click', ()=>{
            addDesign();
        });
        btnRemoveProfile.addEventListener('click', ()=>{
            removeProfile();
        });
        btnRemoveDesign.addEventListener('click', ()=>{
            removeDesign();
        });
        document.getElementById('btn-rename-design').addEventListener('click', ()=>{
            renameDesign();
        });
        document.getElementById('btn-clone-design').addEventListener('click', ()=>{
            cloneDesign();
        });
        canvasSelector.addEventListener('change', (e)=>{
            switchCanvas(parseInt(e.target.value));
            saveCurrentDesign();
        });
        canvas2Checkbox.addEventListener('change', (e)=>{
            toggleCanvas2(e.target.checked);
        });
    fileInput.addEventListener('change', (ev)=>{
        const f = ev.target.files && ev.target.files[0];
        if(!f) return;
        const reader = new FileReader();
            reader.onload = function(e){ importFromFile(e.target.result); };
        reader.readAsText(f);
    });

    window.addEventListener('keydown', (e)=>{
        if((e.ctrlKey||e.metaKey) && e.key.toLowerCase() === 'e'){ e.preventDefault(); exportToFile(); msg('Layout exported to file.'); }
    });

        // Listen for window resize to detect full screen mode changes
        window.addEventListener('resize', () => {
            checkFullScreenMode();
            // Also fit canvas when resizing in widget mode
            if (!isFullScreen) {
                setTimeout(() => {
                    fit();
                }, 50);
            }
        });

    // ---------- Zoom / fit ----------
        function setZoom(nz){ 
            z = Math.max(.1, Math.min(3, nz)); 
            // Combina zoom e rotazione del canvas
            if(canvasRotation === 0){
                cw.style.transform = `scale(${z})`;
            } else {
                cw.style.transform = `rotate(${canvasRotation}deg) scale(${z})`;
            }
            zd.textContent = `${Math.round(z*100)}%`; 
        }
    function fit(){ const cr = cc.getBoundingClientRect(); const hw = (cr.width-40)/(W*37.795276); const vw = (cr.height-40)/(H*37.795276); setZoom(Math.min(hw,vw,1.5)); }

        // ---------- Full screen detection & UI visibility ----------
        function checkFullScreenMode() {
            // Se la finestra √® molto piccola, probabilmente √® in modalit√† widget
            // Soglia: se width < 600px o height < 400px, consideralo widget mode
            const isWidget = window.innerWidth < 600 || window.innerHeight < 400;
            const wasFullScreen = isFullScreen;
            isFullScreen = !isWidget;
            
            // Se si √® appena entrati in full screen, applica fit zoom
            if(isFullScreen && !wasFullScreen){
                setTimeout(() => {
                    fit();
                }, 100);
            }
            
            updateUIVisibility();
        }

        function updateUIVisibility() {
            const toolbar = document.getElementById('toolbar');
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('main-content');
            const canvasContainer = document.getElementById('canvas-container');
            
            if (isFullScreen) {
                // Mostra tutta la UI
                toolbar.style.display = 'flex';
                sidebar.style.display = 'flex';
                mainContent.style.flexDirection = 'row';
                mainContent.style.justifyContent = '';
                mainContent.style.alignItems = '';
                
                // Rimuovi classe widget-mode per abilitare interazioni
                document.body.classList.remove('widget-mode');
                
                // Nascondi mini toolbar se esiste
                const miniToolbar = document.getElementById('mini-toolbar');
                if (miniToolbar) {
                    miniToolbar.style.display = 'none';
                }
                    
                    // Fix focus: quando si entra in full screen, assicurati che il focus sia sul canvas
                    // per evitare che gli eventi della tastiera vengano intercettati da altri elementi
                    setTimeout(() => {
                        const activeElement = document.activeElement;
                        // Se il focus √® su un elemento che non √® pi√π visibile o non dovrebbe avere il focus,
                        // spostalo sul canvas container
                        if (activeElement && activeElement !== document.body && activeElement !== document.documentElement) {
                            // Controlla se l'elemento attivo √® visibile
                            const isVisible = activeElement.offsetParent !== null;
                            const style = window.getComputedStyle(activeElement);
                            const isDisplayed = style.display !== 'none' && style.visibility !== 'hidden';
                            
                            // Se l'elemento non √® visibile o non √® un input/textarea/select attivo e visibile, sposta il focus
                            if (!isVisible || !isDisplayed || (activeElement.tagName !== 'INPUT' && activeElement.tagName !== 'TEXTAREA' && activeElement.tagName !== 'SELECT')) {
                                // Sposta il focus sul canvas container per assicurarsi che gli eventi vengano gestiti correttamente
                                if (canvasContainer) {
                                    if (canvasContainer.tabIndex === -1) {
                                        canvasContainer.setAttribute('tabindex', '-1');
                                    }
                                    canvasContainer.focus();
                                }
                            }
                        } else {
                            // Se non c'√® focus, impostalo sul canvas container
                            if (canvasContainer) {
                                if (canvasContainer.tabIndex === -1) {
                                    canvasContainer.setAttribute('tabindex', '-1');
                                }
                                canvasContainer.focus();
                            }
                        }
                    }, 50);
            } else {
                // Nascondi tutto tranne print, rotate e canvas
                toolbar.style.display = 'none';
                sidebar.style.display = 'none';
                mainContent.style.flexDirection = 'column';
                mainContent.style.justifyContent = 'flex-start';
                mainContent.style.alignItems = 'stretch';
                
                // Aggiungi classe widget-mode al body per disabilitare interazioni
                document.body.classList.add('widget-mode');
                
                // Crea una mini toolbar con print, rotate e selettore profilo
                let miniToolbar = document.getElementById('mini-toolbar');
                if (!miniToolbar) {
                    miniToolbar = document.createElement('div');
                    miniToolbar.id = 'mini-toolbar';
                    const btnPrint = document.getElementById('btn-print').cloneNode(true);
                    btnPrint.id = 'mini-btn-print';
                    btnPrint.addEventListener('click', () => document.getElementById('btn-print').click());
                    const btnRotate = document.getElementById('btn-rotate-canvas').cloneNode(true);
                    btnRotate.id = 'mini-btn-rotate';
                    btnRotate.addEventListener('click', () => document.getElementById('btn-rotate-canvas').click());
                    
                    // Selettore profilo compatto
                    const profileSelect = document.createElement('select');
                    profileSelect.id = 'mini-profile-selector';
                    profileSelect.style.cssText = 'padding:6px 8px;font-size:13px;border:1px solid #ccc;border-radius:4px;background:#fff;min-width:100px;max-width:150px';
                    profileSelect.addEventListener('change', (e) => {
                        profileSelector.value = e.target.value;
                        profileSelector.dispatchEvent(new Event('change'));
                    });
                    
                    // Selettore design compatto
                    const designSelect = document.createElement('select');
                    designSelect.id = 'mini-design-selector';
                    designSelect.style.cssText = 'padding:6px 8px;font-size:13px;border:1px solid #ccc;border-radius:4px;background:#fff;min-width:100px;max-width:150px';
                    designSelect.addEventListener('change', (e) => {
                        designSelector.value = e.target.value;
                        designSelector.dispatchEvent(new Event('change'));
                    });
                    
                    // Selettore canvas compatto (solo se canvas2 √® abilitato)
                    const canvasSelect = document.createElement('select');
                    canvasSelect.id = 'mini-canvas-selector';
                    canvasSelect.style.cssText = 'padding:6px 8px;font-size:13px;border:1px solid #ccc;border-radius:4px;background:#fff;min-width:80px;max-width:120px;display:none';
                    canvasSelect.innerHTML = '<option value="1">Canvas 1</option><option value="2">Canvas 2</option>';
                    canvasSelect.addEventListener('change', (e) => {
                        canvasSelector.value = e.target.value;
                        canvasSelector.dispatchEvent(new Event('change'));
                    });
                    
                    miniToolbar.appendChild(btnPrint);
                    miniToolbar.appendChild(btnRotate);
                    miniToolbar.appendChild(profileSelect);
                    miniToolbar.appendChild(designSelect);
                    miniToolbar.appendChild(canvasSelect);
                    mainContent.insertBefore(miniToolbar, canvasContainer);
                }
                
                // Aggiorna i selettori nella mini toolbar
                const miniProfileSelect = document.getElementById('mini-profile-selector');
                if (miniProfileSelect) {
                    miniProfileSelect.innerHTML = Object.keys(profiles).map(key => {
                        const p = profiles[key];
                        return `<option value="${key}" ${key===currentProfile?'selected':''}>${p.width} √ó ${p.height} cm</option>`;
                    }).join('');
                }
                
                const miniDesignSelect = document.getElementById('mini-design-selector');
                if (miniDesignSelect) {
                    const profile = profiles[currentProfile];
                    if (profile) {
                        miniDesignSelect.innerHTML = Object.keys(profile.designs).map(key => {
                            return `<option value="${key}" ${key===currentDesign?'selected':''}>${key}</option>`;
                        }).join('');
                    }
                }
                
                // Aggiorna il selettore canvas nella mini toolbar
                const miniCanvasSelect = document.getElementById('mini-canvas-selector');
                if (miniCanvasSelect) {
                    const profile = profiles[currentProfile];
                    if (profile && profile.designs[currentDesign]) {
                        const design = profile.designs[currentDesign];
                        const canvas2Flag = design.canvas2Enabled || false;
                        // Mostra solo se canvas2 √® abilitato
                        miniCanvasSelect.style.display = canvas2Flag ? 'block' : 'none';
                        miniCanvasSelect.value = currentCanvas.toString();
                    }
                }
                
                miniToolbar.style.display = 'flex';
                
                // Fit canvas to window after layout update (considerando la toolbar)
                setTimeout(() => {
                    // Calcola lo spazio disponibile per il canvas (escludendo la toolbar)
                    const toolbarHeight = miniToolbar ? miniToolbar.offsetHeight : 0;
                    const availableHeight = window.innerHeight - toolbarHeight;
                    const availableWidth = window.innerWidth;
                    const cr = cc.getBoundingClientRect();
                    const hw = (availableWidth - 40) / (W * 37.795276);
                    const vw = (availableHeight - 40) / (H * 37.795276);
                    setZoom(Math.min(hw, vw, 1.5));
                }, 50);
            }
        }

    // ---------- Grist integration (optional) ----------
    if(isGristAvailable()){
        try{ window.grist.ready({ requiredAccess:'full' }); }catch(e){}
        try{
            if(typeof window.grist.onRecord === 'function'){
                window.grist.onRecord(function(record,mappings){ 
                    R = record||{}; 
                    C = Object.keys(R); 
                    if(selectedIds.length) {
                        updateProps(); 
                    } else {
                        // Update count display even when no elements are selected
                        if(typeof window.updateSequenceCountDisplay === 'function'){
                            window.updateSequenceCountDisplay();
                        }
                    }
                    render(); 
                });
            }
        }catch(e){ console.warn('grist.onRecord error',e); }
        try{
            if(typeof window.grist.onOptions === 'function'){
                window.grist.onOptions(function(options){ /* no-op */ });
            }
        }catch(e){}
    } else { R = {}; C = []; }

        // ---------- Initial setup & history init ----------
        // Load from localStorage on startup
        try {
            const saved = localStorage.getItem(KEY);
            if(saved){
                const parsed = JSON.parse(saved);
                if(parsed && parsed.version === 2 && parsed.profiles){
                    profiles = parsed.profiles;
                    // Ensure backward compatibility: add sequence fields to all designs
                    Object.keys(profiles).forEach(profileKey => {
                        const profile = profiles[profileKey];
                        if(profile && profile.designs){
                            Object.keys(profile.designs).forEach(designKey => {
                                const design = profile.designs[designKey];
                                if(design){
                                    if(design.sequenceEnabled === undefined) design.sequenceEnabled = false;
                                }
                            });
                        }
                    });
                    // Load lastDesignByProfile if saved (before restoring current profile/design)
                    if(parsed.lastDesignByProfile && typeof parsed.lastDesignByProfile === 'object'){
                        lastDesignByProfile = parsed.lastDesignByProfile;
                    }
                    // Load lastCanvasByProfile if saved
                    if(parsed.lastCanvasByProfile && typeof parsed.lastCanvasByProfile === 'object'){
                        lastCanvasByProfile = parsed.lastCanvasByProfile;
                    }
                    // Load lastCanvasByDesign if saved
                    if(parsed.lastCanvasByDesign && typeof parsed.lastCanvasByDesign === 'object'){
                        lastCanvasByDesign = parsed.lastCanvasByDesign;
                    }
                    // Load globalSequenceCountColumn if saved
                    if(parsed.globalSequenceCountColumn !== undefined){
                        globalSequenceCountColumn = parsed.globalSequenceCountColumn || '';
                    }
                    // Restore current profile, design and canvas if saved
                    if(parsed.currentProfile && profiles[parsed.currentProfile]){
                        currentProfile = parsed.currentProfile;
                        const profile = profiles[currentProfile];
                        if(parsed.currentDesign && profile.designs[parsed.currentDesign]){
                            currentDesign = parsed.currentDesign;
                            // Also update lastDesignByProfile for this profile
                            lastDesignByProfile[currentProfile] = currentDesign;
                        } else {
                            // Try to use last selected design for this profile
                            const lastDesign = lastDesignByProfile[currentProfile];
                            const designKeys = Object.keys(profile.designs);
                            if(lastDesign && designKeys.includes(lastDesign)){
                                currentDesign = lastDesign;
                            } else if(designKeys.length > 0){
                                // Fallback to first design if saved design doesn't exist
                                currentDesign = designKeys[0];
                            }
                        }
                        
                        // Restore canvas: try saved canvas, then last canvas for design, then last canvas for profile, then default
                        const design = profile.designs[currentDesign];
                        if(parsed.currentCanvas === 1 || parsed.currentCanvas === 2){
                            currentCanvas = parsed.currentCanvas;
                            if(currentCanvas === 2 && !(design && design.canvas2Enabled)){
                                // Fallback: try last canvas for this design
                                const lastCanvasForDesign = lastCanvasByDesign[currentDesign];
                                if(lastCanvasForDesign === 1 || (lastCanvasForDesign === 2 && design && design.canvas2Enabled)){
                                    currentCanvas = lastCanvasForDesign;
                                } else {
                                    // Try last canvas for profile
                                    const lastCanvasForProfile = lastCanvasByProfile[currentProfile];
                                    if(lastCanvasForProfile === 1 || (lastCanvasForProfile === 2 && design && design.canvas2Enabled)){
                                        currentCanvas = lastCanvasForProfile;
                                    } else {
                                        currentCanvas = 1; // Fallback to canvas 1
                                    }
                                }
                            }
                            // Also update lastCanvasByDesign for this design
                            lastCanvasByDesign[currentDesign] = currentCanvas;
                        } else {
                            // Try to use last selected canvas for this design
                            const lastCanvasForDesign = lastCanvasByDesign[currentDesign];
                            if(lastCanvasForDesign === 1 || (lastCanvasForDesign === 2 && design && design.canvas2Enabled)){
                                currentCanvas = lastCanvasForDesign;
                            } else {
                                // Try last canvas for profile
                                const lastCanvasForProfile = lastCanvasByProfile[currentProfile];
                                if(lastCanvasForProfile === 1 || (lastCanvasForProfile === 2 && design && design.canvas2Enabled)){
                                    currentCanvas = lastCanvasForProfile;
                                } else {
                                    currentCanvas = 1; // Default to canvas 1
                                }
                            }
                            // Also update lastCanvasByDesign for this design
                            lastCanvasByDesign[currentDesign] = currentCanvas;
                        }
                    } else {
                        // Fallback: use first available profile and design
                        const profileKeys = Object.keys(profiles);
                        if(profileKeys.length > 0){
                            currentProfile = profileKeys[0];
                            const designKeys = Object.keys(profiles[currentProfile].designs);
                            if(designKeys.length > 0){a
                                // Try to use last selected design for this profile
                                const lastDesign = lastDesignByProfile[currentProfile];
                                if(lastDesign && designKeys.includes(lastDesign)){
                                    currentDesign = lastDesign;
                                } else {
                                    currentDesign = designKeys[0];
                                }
                                // Update last selected design for current profile
                                lastDesignByProfile[currentProfile] = currentDesign;
                                
                                // Try to use last selected canvas for this profile
                                const fallbackDesign = profiles[currentProfile].designs[currentDesign];
                                const lastCanvas = lastCanvasByProfile[currentProfile];
                                if(lastCanvas === 1 || (lastCanvas === 2 && fallbackDesign && fallbackDesign.canvas2Enabled)){
                                    currentCanvas = lastCanvas;
                                } else {
                                    currentCanvas = 1; // Default to canvas 1
                                }
                                // Update last selected canvas for current profile and design
                                lastCanvasByProfile[currentProfile] = currentCanvas;
                                lastCanvasByDesign[currentDesign] = currentCanvas;
                            }
                        }
                    }
                        // Load groups if saved
                        if(parsed.groups && Array.isArray(parsed.groups)){
                            groups = parsed.groups;
                            // Validate groups - remove groups with non-existent elements
                            groups = groups.filter(group => {
                                group.elementIds = group.elementIds.filter(id => S.some(e => e.id === id));
                                return group.elementIds.length > 0;
                            });
                            // Recalculate bounds for loaded groups
                            groups.forEach(group => {
                                group.bounds = getGroupBounds(group.elementIds);
                            });
                    }
                }
            }
        } catch(e) {
            console.warn('Failed to load from localStorage:', e);
        }
        
        // Initialize canvas size immediately
        updateCanvasSize();
        updateProfileSelector();
        updateDesignSelector();
        updateCanvasControls();
        loadCurrentDesign();
            // Recalculate group bounds after loading elements
            groups.forEach(group => {
                group.bounds = getGroupBounds(group.elementIds);
            });
        render();
        updateProps();
        fit();
    resetHistory();
        
        // Check full screen mode on initial load
        checkFullScreenMode();
        
        // Sync button heights with select on initial load
        setTimeout(() => {
            const selectHeight = designSelector.offsetHeight;
            const renameBtn = document.getElementById('btn-rename-design');
            const cloneBtn = document.getElementById('btn-clone-design');
            if(renameBtn && selectHeight) renameBtn.style.height = `${selectHeight}px`;
            if(cloneBtn && selectHeight) cloneBtn.style.height = `${selectHeight}px`;
        }, 100);

}); // DOMContentLoaded
</script>

</body>
</html>