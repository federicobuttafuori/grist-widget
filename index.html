<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Grist Label Designer ‚Äî Marquee Fix</title>
    <script src="https://docs.getgrist.com/grist-plugin-api.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
    <style>
        *{box-sizing:border-box;margin:0;padding:0}
        html,body{height:100vh;width:100vw;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;display:flex;flex-direction:column;overflow:hidden;background:#f0f0f0;color:#333}
        button{padding:6px 10px;border:1px solid #ccc;background:#fff;border-radius:4px;cursor:pointer;font-size:14px;transition:all .2s}
        button:hover{background:#f9f9f9;border-color:#aaa}
        button:active{background:#e0e0e0}
        button:disabled{opacity:.5;cursor:not-allowed}
        input,select,textarea{width:100%;padding:6px;border:1px solid #ccc;border-radius:4px;font-size:14px}
        textarea{resize:vertical;min-height:60px}
        hr{border:none;border-top:1px solid #eee;margin:12px 0}
        #toolbar{flex-shrink:0;padding:8px;background:#fff;border-bottom:1px solid #e0e0e0;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
        #toolbar .zoom-label{font-size:14px;margin-left:auto}
        #toolbar .divider{width:1px;height:24px;background:#e0e0e0;margin:0 4px}
        #main-content{display:flex;flex-grow:1;overflow:hidden}
        #sidebar{width:320px;flex-shrink:0;background:#fdfdfd;border-right:1px solid #e0e0e0;padding:12px;overflow-y:auto;display:flex;flex-direction:column;gap:16px}
        .profile-section{background:#f5f5f5;padding:10px;border-radius:6px;border:1px solid #e0e0e0}
        .profile-section select{margin-bottom:8px}
        .profile-section .button-row{display:flex;gap:4px;margin-top:8px}
        .profile-section .button-row button{flex:1;font-size:12px;padding:4px 8px}
        #sidebar h3{font-size:16px;font-weight:600;border-bottom:1px solid #eee;padding-bottom:6px;margin-bottom:4px}
        .sidebar-section{display:flex;flex-direction:column;gap:8px}
        .sidebar-section .add-buttons{display:grid;grid-template-columns:1fr 1fr;gap:8px}
        .prop-grid{display:grid;grid-template-columns:90px 1fr;gap:8px;align-items:center}
        .prop-grid label{font-size:14px;font-weight:500}
        .prop-full{grid-column:1/-1}
        #properties-panel{font-size:14px}
        #btn-delete{background:#fbebeb;border-color:#d9a0a0;color:#c00;margin-top:12px}
        #btn-delete:hover{background:#f7dada}
        .button-group{display:flex;gap:4px}
        #canvas-container{flex-grow:1;display:flex;justify-content:center;align-items:center;overflow:auto;background:#e0e0e0;padding:20px;position:relative}
        #canvas-wrapper{display:inline-block;transform-origin:center center;position:relative}
        #label-canvas{background:#fff;box-shadow:0 4px 12px rgba(0,0,0,.15);position:relative;overflow:hidden}
        #marquee{position:absolute;border:1px dashed #007aff;background:rgba(0,122,255,0.08);pointer-events:none;display:none;z-index:9999}
        @media print{
            @page{margin:0}
            html,body{margin:0!important;padding:0!important;width:8cm!important;height:5cm!important;overflow:visible!important;background:#fff!important}
            #toolbar,#sidebar,#marquee,.status-message{display:none!important}
            #main-content{width:8cm!important;height:5cm!important;overflow:visible!important;display:block!important;padding:0!important;margin:0!important}
            #canvas-container{width:8cm!important;height:5cm!important;padding:0!important;margin:0!important;overflow:visible!important;background:#fff!important;display:block!important;position:static!important}
            #canvas-wrapper{position:static!important;width:8cm!important;height:5cm!important;margin:0!important;padding:0!important;transform:none!important;display:block!important}
            #label-canvas{position:static!important;width:8cm!important;height:5cm!important;transform:none!important;box-shadow:none!important;display:block!important;overflow:visible!important;background:#fff!important}
            .label-element{page-break-inside:avoid!important}
            .label-element.selected{border:1px solid transparent!important;box-shadow:none!important}
            .resize-handle{display:none!important}
        }
        .label-element{position:absolute;cursor:move;border:1px solid transparent;font-size:16px;line-height:1.2;overflow:hidden;word-wrap:break-word;user-select:none;transform-origin:center center}
        .label-element.selected{border:2px dashed #007aff;box-shadow:0 0 0 1px rgba(0,122,255,.1)}
        .resize-handle{position:absolute;width:12px;height:12px;background:#007aff;border:2px solid #fff;border-radius:50%;bottom:-6px;right:-6px;cursor:nwse-resize;display:none;box-shadow:0 2px 4px rgba(0,0,0,.2)}
        .label-element.selected .resize-handle{display:block}
        .label-element img,.label-element svg{width:100%;height:100%;object-fit:contain;pointer-events:none}
        .status-message{position:fixed;top:60px;right:20px;padding:12px 16px;background:#4CAF50;color:#fff;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,.2);z-index:1000;animation:slideIn .3s ease-out}
        @keyframes slideIn{from{transform:translateX(400px);opacity:0}to{transform:translateX(0);opacity:1}}
        .status-message.error{background:#f44336}
    </style>
</head>
<body>
    <div id="toolbar">
        <button id="btn-save" title="Save Layout">üíæ Save</button>
        <button id="btn-load" title="Load Layout">üìÇ Load</button>
        <button id="btn-clear" title="Clear Layout">üóëÔ∏è Clear</button>
        <div class="divider"></div>
        <button id="btn-print" title="Print Label">üñ®Ô∏è Print</button>
        <div class="divider"></div>
        <button id="btn-duplicate" title="Duplicate Selected Elements" disabled>üìã Duplicate</button>
        <button id="btn-bring-front" title="Bring to Front" disabled>‚¨ÜÔ∏è Front</button>
        <button id="btn-send-back" title="Send to Back" disabled>‚¨áÔ∏è Back</button>
        <span class="zoom-label">Zoom:</span>
        <div class="button-group">
            <button id="btn-zoom-out" title="Zoom Out">-</button>
            <button id="btn-zoom-in" title="Zoom In">+</button>
            <button id="btn-zoom-fit" title="Fit to Screen">Fit</button>
        </div>
        <span id="zoom-display">100%</span>
    </div>

    <div id="main-content">
        <div id="sidebar">
            <div class="sidebar-section profile-section">
                <h3>Label Profile</h3>
                <label>Size:</label>
                <select id="profile-selector">
                    <option value="8x5">8 √ó 5 cm</option>
                </select>
                <label>Design:</label>
                <select id="design-selector">
                    <option value="default">Default</option>
                </select>
                <div class="button-row">
                    <button id="btn-add-profile">‚ûï Add Size</button>
                    <button id="btn-add-design">‚ûï Add Design</button>
                </div>
                <div class="button-row">
                    <button id="btn-remove-profile" style="background:#fbebeb;border-color:#d9a0a0;color:#c00">üóëÔ∏è Remove Size</button>
                    <button id="btn-remove-design" style="background:#fbebeb;border-color:#d9a0a0;color:#c00">üóëÔ∏è Remove Design</button>
                </div>
            </div>
            <hr>
            <div class="sidebar-section">
                <h3>Add Element</h3>
                <div class="add-buttons">
                    <button class="add-element" data-type="text">üìù Text</button>
                    <button class="add-element" data-type="data">üîó Data Field</button>
                    <button class="add-element" data-type="qr">üì± QR Code</button>
                    <button class="add-element" data-type="barcode">üìä Barcode</button>
                    <button class="add-element" data-type="line">‚ûñ Line</button>
                    <button class="add-element" data-type="box">‚¨ú Box</button>
                </div>
            </div>
            <hr>
            <div class="sidebar-section">
                <h3>Properties</h3>
                <div id="properties-panel">Select an element to edit its properties.</div>
            </div>
            <hr>
            <div class="sidebar-section">
                <h3>Import/Export</h3>
                <div style="display:flex;gap:8px">
                    <button id="btn-export">‚¨áÔ∏è Export</button>
                    <button id="btn-import">‚¨ÜÔ∏è Import</button>
                </div>
                <small>Tip: Ctrl/Cmd+E exports layout. Ctrl/Cmd+Z = undo, Ctrl/Cmd+Shift+Z = redo</small>
            </div>
        </div>

        <div id="canvas-container">
            <div id="canvas-wrapper">
                <div id="label-canvas"></div>
            </div>
            <div id="marquee"></div>
        </div>
    </div>

    <input id="file-import" type="file" accept="application/json" style="display:none" />

<script>
document.addEventListener('DOMContentLoaded', ()=>{

    // ---------- State ----------
    let S = [];                       // elements array
    let selectedIds = [];             // array of selected element ids (multi-select)
    let z = 1;
    let R = {}, C = [];
    let drag = false, resizeMode = false, ctx = {};
    let W = 8, H = 5;                 // Current dimensions (dynamic)
    const KEY = 'grist_label_layout_v2'; // Updated version for profiles
    const MAX_HISTORY = 100;
    
    // Profile management
    let profiles = {
        '8x5': {
            width: 8,
            height: 5,
            designs: {
                'default': []
            }
        }
    };
    let currentProfile = '8x5';
    let currentDesign = 'default';

    // History stacks for undo/redo
    let history = [];
    let historyIndex = -1;

    // Search debounce timer
    let searchDebounceTimer = null;

    // DOM refs
    const cc = document.getElementById('canvas-container');
    const cw = document.getElementById('canvas-wrapper');
    const lc = document.getElementById('label-canvas');
    const pp = document.getElementById('properties-panel');
    const zd = document.getElementById('zoom-display');
    const bd = document.getElementById('btn-duplicate');
    const bf = document.getElementById('btn-bring-front');
    const bs = document.getElementById('btn-send-back');
    const fileInput = document.getElementById('file-import');
    const btnExport = document.getElementById('btn-export');
    const btnImport = document.getElementById('btn-import');
    const marquee = document.getElementById('marquee');
    const profileSelector = document.getElementById('profile-selector');
    const designSelector = document.getElementById('design-selector');
    const btnAddProfile = document.getElementById('btn-add-profile');
    const btnAddDesign = document.getElementById('btn-add-design');
    const btnRemoveProfile = document.getElementById('btn-remove-profile');
    const btnRemoveDesign = document.getElementById('btn-remove-design');

    // Marquee state
    let marqueeActive = false;
    let marqueeStart = { clientX:0, clientY:0, startX:0, startY:0, containerRect:null };

    // ---------- Utilities ----------
    function msg(m, error=false, timeout=3000){
        const x = document.querySelector('.status-message'); if(x) x.remove();
        const s = document.createElement('div'); s.className = 'status-message' + (error ? ' error' : ''); s.textContent = m;
        document.body.appendChild(s); setTimeout(()=>{ if(s.parentNode) s.parentNode.removeChild(s) }, timeout);
    }

    function isGristAvailable(){ return (typeof window.grist !== 'undefined' && window.grist && typeof window.grist.getOption === 'function' && typeof window.grist.setOption === 'function'); }

    function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

    // ---------- Profile Management ----------
    function updateCanvasSize(){
        const profile = profiles[currentProfile];
        if(!profile) return;
        W = profile.width;
        H = profile.height;
        lc.style.width = `${W}cm`;
        lc.style.height = `${H}cm`;
        updatePrintCSS();
        fit();
    }

    function updatePrintCSS(){
        const styleId = 'dynamic-print-css';
        let styleEl = document.getElementById(styleId);
        if(!styleEl){
            styleEl = document.createElement('style');
            styleEl.id = styleId;
            document.head.appendChild(styleEl);
        }
        const profile = profiles[currentProfile];
        if(profile){
            styleEl.textContent = `
                @media print{
                    @page{size:${profile.width}cm ${profile.height}cm;margin:0}
                    html,body{margin:0!important;padding:0!important;width:${profile.width}cm!important;height:${profile.height}cm!important;overflow:visible!important;background:#fff!important}
                    #toolbar,#sidebar,#marquee,.status-message{display:none!important}
                    #main-content{width:${profile.width}cm!important;height:${profile.height}cm!important;overflow:visible!important;display:block!important;padding:0!important;margin:0!important}
                    #canvas-container{width:${profile.width}cm!important;height:${profile.height}cm!important;padding:0!important;margin:0!important;overflow:visible!important;background:#fff!important;display:block!important;position:static!important}
                    #canvas-wrapper{position:static!important;width:${profile.width}cm!important;height:${profile.height}cm!important;margin:0!important;padding:0!important;transform:none!important;display:block!important}
                    #label-canvas{position:static!important;width:${profile.width}cm!important;height:${profile.height}cm!important;transform:none!important;box-shadow:none!important;display:block!important;overflow:visible!important;background:#fff!important}
                    .label-element{page-break-inside:avoid!important}
                    .label-element.selected{border:1px solid transparent!important;box-shadow:none!important}
                    .resize-handle{display:none!important}
                }
            `;
        }
    }

    function updateProfileSelector(){
        profileSelector.innerHTML = Object.keys(profiles).map(key => {
            const p = profiles[key];
            return `<option value="${key}" ${key===currentProfile?'selected':''}>${p.width} √ó ${p.height} cm</option>`;
        }).join('');
    }

    function updateDesignSelector(){
        const profile = profiles[currentProfile];
        if(!profile) return;
        designSelector.innerHTML = Object.keys(profile.designs).map(key => {
            return `<option value="${key}" ${key===currentDesign?'selected':''}>${key}</option>`;
        }).join('');
    }

    function switchProfile(profileKey){
        if(!profiles[profileKey]) return;
        // Save current design before switching
        saveCurrentDesign();
        // Switch profile
        currentProfile = profileKey;
        // Switch to first design in new profile
        currentDesign = Object.keys(profiles[profileKey].designs)[0] || 'default';
        // Load the design
        loadCurrentDesign();
        updateCanvasSize();
        updateProfileSelector();
        updateDesignSelector();
        render();
        updateProps();
    }

    function switchDesign(designKey){
        const profile = profiles[currentProfile];
        if(!profile || !profile.designs[designKey]) return;
        // Save current design before switching
        saveCurrentDesign();
        // Switch design
        currentDesign = designKey;
        // Load the new design
        loadCurrentDesign();
        updateDesignSelector();
        render();
        updateProps();
    }

    function saveCurrentDesign(){
        const profile = profiles[currentProfile];
        if(!profile) return;
        if(!profile.designs[currentDesign]) profile.designs[currentDesign] = [];
        profile.designs[currentDesign] = deepCopy(S);
    }

    function loadCurrentDesign(){
        const profile = profiles[currentProfile];
        if(!profile) return;
        if(!profile.designs[currentDesign]) profile.designs[currentDesign] = [];
        S = profile.designs[currentDesign].map(normalizeElement);
        selectedIds = [];
    }

    function addProfile(){
        const width = prompt('Enter label width (cm):', '10');
        if(!width || isNaN(parseFloat(width))) return;
        const height = prompt('Enter label height (cm):', '7.5');
        if(!height || isNaN(parseFloat(height))) return;
        const w = parseFloat(width);
        const h = parseFloat(height);
        if(w <= 0 || h <= 0) { msg('Invalid dimensions', true); return; }
        const key = `${w}x${h}`;
        if(profiles[key]) { msg('Profile already exists', true); return; }
        // Save current before switching
        saveCurrentDesign();
        // Create new profile
        profiles[key] = {
            width: w,
            height: h,
            designs: {
                'default': []
            }
        };
        switchProfile(key);
        msg(`Profile ${w} √ó ${h} cm added`);
        save();
    }

    function removeProfile(){
        if(Object.keys(profiles).length <= 1){
            msg('Cannot remove the last profile', true);
            return;
        }
        if(!confirm(`Remove profile ${currentProfile}? All designs in this profile will be lost.`)) return;
        delete profiles[currentProfile];
        // Switch to first available profile
        const firstKey = Object.keys(profiles)[0];
        switchProfile(firstKey);
        msg('Profile removed');
        save();
    }

    function addDesign(){
        const name = prompt('Enter design name:', 'Design ' + (Object.keys(profiles[currentProfile].designs).length + 1));
        if(!name || !name.trim()) return;
        const designKey = name.trim();
        const profile = profiles[currentProfile];
        if(profile.designs[designKey]) { msg('Design already exists', true); return; }
        // Save current before switching
        saveCurrentDesign();
        // Create new empty design
        profile.designs[designKey] = [];
        switchDesign(designKey);
        msg(`Design "${designKey}" added`);
        save();
    }

    function removeDesign(){
        const profile = profiles[currentProfile];
        if(Object.keys(profile.designs).length <= 1){
            msg('Cannot remove the last design', true);
            return;
        }
        if(!confirm(`Remove design "${currentDesign}"?`)) return;
        delete profile.designs[currentDesign];
        // Switch to first available design
        const firstKey = Object.keys(profile.designs)[0];
        switchDesign(firstKey);
        msg('Design removed');
        save();
    }

    // ---------- History (undo/redo) ----------
    function pushHistorySnapshot(){
        if(historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
        history.push({
            data: deepCopy(S),
            sel: deepCopy(selectedIds)
        });
        if(history.length > MAX_HISTORY) history.shift();
        historyIndex = history.length - 1;
    }

    function resetHistory(){
        history = [];
        historyIndex = -1;
        pushHistorySnapshot();
    }

    function undo(){
        if(historyIndex <= 0) { msg('Nothing to undo'); return; }
        historyIndex--;
        const snap = history[historyIndex];
        S = deepCopy(snap.data);
        selectedIds = deepCopy(snap.sel);
        render();
        updateProps();
        updateBtns();
        save();
        msg('Undo');
    }

    function redo(){
        if(historyIndex >= history.length - 1) { msg('Nothing to redo'); return; }
        historyIndex++;
        const snap = history[historyIndex];
        S = deepCopy(snap.data);
        selectedIds = deepCopy(snap.sel);
        render();
        updateProps();
        updateBtns();
        save();
        msg('Redo');
    }

    // ---------- Element normalization ----------
    function normalizeElement(el){
        if(!el) return null;
        const defaults = {
            id: `el_${Date.now()}`,
            type: 'text',
            x: 0.5, y: 0.5, width: 1.5, height: 0.5, zIndex: 0,
            props: {
                text: 'Sample Text',
                fontSize: 16, fontWeight: 'normal', fontFamily: 'Arial, sans-serif',
                textAlign: 'left', valign: 'top', color: '#000000',
                boundColumn: '', prefix:'', suffix:'', rotation:0,
                showBorder:false, borderColor:'#000000', borderWidth:1,
                paddingTop: 0, paddingRight: 0, paddingBottom: 0, paddingLeft: 0,
                thickness:2, format:'CODE128', displayValue:true,
                fillColor:'#ffffff', decimals:2, asPercent:false
            }
        };

        // Merge top-level / props
        const base = Object.assign({}, defaults, el);
        base.props = Object.assign({}, defaults.props, el && el.props ? el.props : {});

        // If old single padding exists (legacy data), convert to sides
        if(base.props.padding !== undefined && !isNaN(Number(base.props.padding))){
            const v = Number(base.props.padding);
            base.props.paddingTop = base.props.paddingTop !== undefined ? Number(base.props.paddingTop) : v;
            base.props.paddingRight = base.props.paddingRight !== undefined ? Number(base.props.paddingRight) : v;
            base.props.paddingBottom = base.props.paddingBottom !== undefined ? Number(base.props.paddingBottom) : v;
            base.props.paddingLeft = base.props.paddingLeft !== undefined ? Number(base.props.paddingLeft) : v;
        } else {
            base.props.paddingTop = Number(base.props.paddingTop) || 0;
            base.props.paddingRight = Number(base.props.paddingRight) || 0;
            base.props.paddingBottom = Number(base.props.paddingBottom) || 0;
            base.props.paddingLeft = Number(base.props.paddingLeft) || 0;
        }

        base.x = Number(base.x) || 0;
        base.y = Number(base.y) || 0;
        base.width = Number(base.width) || 1;
        base.height = Number(base.height) || 1;
        base.zIndex = Number(base.zIndex) || 0;
        base.props.fontSize = Number(base.props.fontSize) || 16;
        base.props.decimals = Number(base.props.decimals) || 0;
        base.props.thickness = Number(base.props.thickness) || 2;
        base.props.borderWidth = Number(base.props.borderWidth) || 1;
        base.props.displayValue = (base.props.displayValue !== false);
        base.props.asPercent = !!base.props.asPercent;
        base.props.rotation = Number(base.props.rotation) || 0;
        base.props.valign = base.props.valign || 'top';
        base.props.prefix = base.props.prefix || '';
        base.props.suffix = base.props.suffix || '';
        base.props.showBorder = !!base.props.showBorder;
        base.props.borderColor = base.props.borderColor || '#000000';
        return base;
    }

    // ---------- Rendering ----------
    function render(){
        lc.innerHTML = '';
        const sorted = S.slice().sort((a,b)=> (a.zIndex||0) - (b.zIndex||0));
        sorted.forEach(el=>{
            const d = document.createElement('div');
            d.classList.add('label-element');
            d.dataset.id = el.id;
            d.style.left = `${el.x}cm`;
            d.style.top = `${el.y}cm`;
            d.style.width = `${el.width}cm`;
            d.style.height = `${el.height}cm`;
            d.style.zIndex = el.zIndex || 0;
            d.style.fontSize = `${el.props.fontSize || 16}px`;
            d.style.fontWeight = el.props.fontWeight || 'normal';
            d.style.fontFamily = el.props.fontFamily || 'Arial, sans-serif';
            const justifyMap = { left: 'flex-start', center: 'center', right: 'flex-end' };
            const alignMap = { top: 'flex-start', middle: 'center', bottom: 'flex-end' };
            if(el.type !== 'line'){
                d.style.display = 'flex';
                d.style.alignItems = alignMap[el.props.valign] || 'flex-start';
                d.style.justifyContent = justifyMap[el.props.textAlign] || 'flex-start';
                d.style.whiteSpace = 'normal';
            } else {
                d.style.display = '';
                d.style.whiteSpace = '';
            }
            d.style.textAlign = el.props.textAlign || 'left';
            d.style.color = el.props.color || '#000000';
            d.style.boxSizing = 'border-box';
            const rotation = Number(el.props.rotation) || 0;
            d.style.transform = `rotate(${rotation}deg)`;
            d.style.transformOrigin = 'center center';

            // padding sides applied in cm if element is text or data (default 0)
            if((el.type === 'text' || el.type === 'data')){
                const pt = Number.isFinite(Number(el.props.paddingTop)) ? Number(el.props.paddingTop) : 0;
                const pr = Number.isFinite(Number(el.props.paddingRight)) ? Number(el.props.paddingRight) : 0;
                const pb = Number.isFinite(Number(el.props.paddingBottom)) ? Number(el.props.paddingBottom) : 0;
                const pl = Number.isFinite(Number(el.props.paddingLeft)) ? Number(el.props.paddingLeft) : 0;
                d.style.padding = `${pt}cm ${pr}cm ${pb}cm ${pl}cm`;
            } else {
                d.style.padding = '';
            }

            // border
            if(el.props.showBorder && el.type !== 'box'){
                d.style.border = `${Number(el.props.borderWidth)||1}px solid ${el.props.borderColor||'#000'}`;
            } else {
                if(el.type !== 'box') d.style.border = '1px solid transparent';
            }

            // content
            switch(el.type){
                case 'text': {
                    const span = document.createElement('div');
                    span.style.display='block';
                    span.style.width='100%';
                    span.style.pointerEvents='none';
                    span.style.overflow='hidden';
                    span.style.wordWrap='break-word';
                    span.textContent = el.props.text || 'Static Text';
                    d.appendChild(span);
                    break;
                }
                case 'data': {
                    const span = document.createElement('div');
                    span.style.display='block';
                    span.style.width='100%';
                    span.style.pointerEvents='none';
                    span.style.overflow='hidden';
                    span.style.wordWrap='break-word';
                    span.textContent = getData(el);
                    d.appendChild(span);
                    break;
                }
                case 'line':
                    d.style.backgroundColor = el.props.color || '#000000';
                    d.style.height = `${el.props.thickness || 2}px`;
                    d.style.width = `${el.width}cm`;
                    break;
                case 'box':
                    d.style.border = `${el.props.thickness || 2}px solid ${el.props.color || '#000000'}`;
                    d.style.backgroundColor = el.props.fillColor || 'transparent';
                    break;
                case 'qr': {
                    const c = getData(el);
                    const q = document.createElement('img');
                    const dpi = 37.795276;
                    const qs = Math.min(el.width, el.height) * dpi;
                    q.src = `https://api.qrserver.com/v1/create-qr-code/?size=${Math.round(qs)}x${Math.round(qs)}&data=${encodeURIComponent(c)}`;
                    q.style.pointerEvents='none';
                    q.style.width='100%';
                    q.style.height='100%';
                    q.style.objectFit='contain';
                    d.appendChild(q);
                    break;
                }
                case 'barcode': {
                    const c = getData(el) || '';
                    const sv = document.createElementNS('http://www.w3.org/2000/svg','svg');
                    sv.style.pointerEvents='none';
                    sv.setAttribute('width','100%');
                    sv.setAttribute('height','100%');
                    d.appendChild(sv);
                    try{
                        const pxHeight = Math.max(30, (el.height * 37.795276) - 10);
                        JsBarcode(sv, String(c), {
                            format: el.props.format || "CODE128",
                            displayValue: el.props.displayValue !== false,
                            width: 2, height: pxHeight, margin:0
                        });
                    }catch(err){
                        sv.innerHTML = `<text x="10" y="20" fill="red" font-size="12">Invalid barcode</text>`;
                        console.error("Barcode Error:",err);
                    }
                    break;
                }
                default:
                    d.innerText = el.props.text || '';
            }

            // selection visuals
            if(selectedIds.includes(el.id)){
                d.classList.add('selected');
                const h = document.createElement('div');
                h.classList.add('resize-handle');
                d.appendChild(h);
            }

            lc.appendChild(d);
        });
    }

    function getData(el){
        const prefix = el.props.prefix || '';
        const suffix = el.props.suffix || '';
        if(el.props.boundColumn && R && Object.prototype.hasOwnProperty.call(R, el.props.boundColumn)){
            let v = R[el.props.boundColumn];
            if(el.type === 'data' && typeof v === 'number'){
                const dec = (el.props.decimals !== undefined) ? Number(el.props.decimals) : 2;
                const pct = !!el.props.asPercent;
                return prefix + fmt(v,dec,pct) + suffix;
            }
            return prefix + String(v) + suffix;
        }
        return prefix + (el.props.text || 'SAMPLE') + suffix;
    }

    function fmt(v,d,p){
        if(v===null||v===undefined||v==='') return '';
        let n=parseFloat(v);
        if(isNaN(n)) return String(v);
        if(p) n=n*100;
        n=n.toFixed(d);
        return p?n+'%':n;
    }

    // ---------- Selection / Buttons / Props ----------
    function updateBtns(){
        const has = selectedIds.length>0;
        bd.disabled = !has; bf.disabled = !has; bs.disabled = !has;
    }

    function setSelection(ids, append=false){
        if(!Array.isArray(ids)) ids = ids ? [ids] : [];
        if(append){
            ids.forEach(id=>{
                const i = selectedIds.indexOf(id);
                if(i===-1) selectedIds.push(id);
                else selectedIds.splice(i,1);
            });
        } else {
            selectedIds = ids;
        }
        render();
        updateProps();
        updateBtns();
    }

    function toggleSelection(id){
        const i = selectedIds.indexOf(id);
        if(i===-1) selectedIds.push(id);
        else selectedIds.splice(i,1);
        render();
        updateProps();
        updateBtns();
    }

    function updateProps(){
        if(selectedIds.length===0){
            pp.innerHTML = 'Select an element to edit its properties.';
            return;
        }
        if(selectedIds.length===1){
            const el = S.find(x=>x.id===selectedIds[0]);
            if(!el){ pp.innerHTML='Error: Element not found.'; return; }
            singlePropsPanel(el);
            return;
        }
        multiPropsPanel(selectedIds.map(id=>S.find(e=>e.id===id)).filter(Boolean));
    }

    // ---------- Properties Panels ----------
    function singlePropsPanel(el){
        // bound column: render search input + select
        let bindHtml = '';
        if(C && C.length){
            bindHtml = `<div style="display:flex;gap:8px;margin-bottom:8px"><input type="text" placeholder="Search columns..." data-prop="bind_search" style="flex:1"><select data-prop="props.boundColumn" style="flex:1"><option value="">-- Select Column --</option>${C.map(col=>`<option value="${col}" ${el.props.boundColumn===col?'selected':''}>${col}</option>`).join('')}</select></div>`;
        } else {
            bindHtml = `<select data-prop="props.boundColumn"><option value="">-- No columns --</option></select>`;
        }

        let h = `<div class="prop-grid"><label>X</label><input type="number" step="0.1" data-prop="x" value="${(Number(el.x)||0).toFixed(2)}"><label>Y</label><input type="number" step="0.1" data-prop="y" value="${(Number(el.y)||0).toFixed(2)}"></div>`;
        h += `<div class="prop-grid"><label>Width</label><input type="number" step="0.1" data-prop="width" value="${(Number(el.width)||0).toFixed(2)}"><label>Height</label><input type="number" step="0.1" data-prop="height" value="${(Number(el.height)||0).toFixed(2)}"></div><hr>`;

        if(el.type==='text') h += `<label>Text</label><textarea data-prop="props.text">${escapeHtml(el.props.text||'')}</textarea>`;

        if(el.type==='data' || el.type==='qr' || el.type==='barcode'){
            h += `<label>Bound Column</label>${bindHtml}`;
        }

        if(el.type==='data'){
            h += `<label>Prefix</label><input type="text" data-prop="props.prefix" value="${escapeHtml(el.props.prefix||'')}">`;
            h += `<label>Suffix</label><input type="text" data-prop="props.suffix" value="${escapeHtml(el.props.suffix||'')}">`;
            h += `<hr><div class="prop-grid"><label>Decimals</label><input type="number" data-prop="props.decimals" value="${el.props.decimals!==undefined?el.props.decimals:2}" min="0" max="10"><label>As Percent</label><input type="checkbox" data-prop="props.asPercent" ${el.props.asPercent?'checked':''}></div>`;
        }

        if(el.type==='qr' || el.type==='barcode'){
            h += `<label>Fallback Text</label><input type="text" data-prop="props.text" value="${escapeHtml(el.props.text||'')}">`;
        }

        if(el.type==='barcode'){
            h += `<label>Format</label><select data-prop="props.format"><option value="CODE128" ${el.props.format==='CODE128'?'selected':''}>CODE128</option><option value="CODE39" ${el.props.format==='CODE39'?'selected':''}>CODE39</option><option value="EAN13" ${el.props.format==='EAN13'?'selected':''}>EAN13</option><option value="UPC" ${el.props.format==='UPC'?'selected':''}>UPC</option></select><label>Show Text</label><input type="checkbox" data-prop="props.displayValue" ${el.props.displayValue!==false?'checked':''}>`;
        }

        if(el.type==='line'){
            h += `<label>Thickness (px)</label><input type="number" data-prop="props.thickness" value="${el.props.thickness||2}" min="1">`;
        }

        if(el.type==='box'){
            h += `<label>Border (px)</label><input type="number" data-prop="props.thickness" value="${el.props.thickness||2}" min="1"><label>Fill Color</label><input type="color" data-prop="props.fillColor" value="${el.props.fillColor||'#ffffff'}">`;
        }

        if(el.type==='text' || el.type==='data'){
            h += `<hr><div class="prop-grid"><label>Font Size</label><input type="number" data-prop="props.fontSize" value="${el.props.fontSize||16}" min="6" max="200"><label>Font Family</label><select data-prop="props.fontFamily"><option value="Arial, sans-serif" ${(el.props.fontFamily||'Arial, sans-serif')==='Arial, sans-serif'?'selected':''}>Arial</option><option value="'Courier New', monospace" ${el.props.fontFamily==="'Courier New', monospace"?'selected':''}>Courier New</option><option value="Consolas, monospace" ${el.props.fontFamily==='Consolas, monospace'?'selected':''}>Consolas</option><option value="Georgia, serif" ${el.props.fontFamily==='Georgia, serif'?'selected':''}>Georgia</option><option value="'Times New Roman', serif" ${el.props.fontFamily==="'Times New Roman', serif"?'selected':''}>Times New Roman</option><option value="Verdana, sans-serif" ${el.props.fontFamily==='Verdana, sans-serif'?'selected':''}>Verdana</option><option value="'Trebuchet MS', sans-serif" ${el.props.fontFamily==="'Trebuchet MS', sans-serif"?'selected':''}>Trebuchet MS</option><option value="Impact, sans-serif" ${el.props.fontFamily==='Impact, sans-serif'?'selected':''}>Impact</option><option value="'Comic Sans MS', cursive" ${el.props.fontFamily==="'Comic Sans MS', cursive"?'selected':''}>Comic Sans MS</option></select></div>`;
            h += `<div class="prop-grid"><label>Weight</label><select data-prop="props.fontWeight"><option value="normal" ${el.props.fontWeight==='normal'?'selected':''}>Normal</option><option value="bold" ${el.props.fontWeight==='bold'?'selected':''}>Bold</option></select><label>Align</label><select data-prop="props.textAlign"><option value="left" ${el.props.textAlign==='left'?'selected':''}>Left</option><option value="center" ${el.props.textAlign==='center'?'selected':''}>Center</option><option value="right" ${el.props.textAlign==='right'?'selected':''}>Right</option></select></div>`;

            // padding sides as four fields, labels without units
            h += `<div class="prop-grid"><label>Vertical Align</label><select data-prop="props.valign"><option value="top" ${el.props.valign==='top'?'selected':''}>Top</option><option value="middle" ${el.props.valign==='middle'?'selected':''}>Middle</option><option value="bottom" ${el.props.valign==='bottom'?'selected':''}>Bottom</option></select><label>Padding Top</label><input type="number" step="0.1" data-prop="props.paddingTop" value="${Number(el.props.paddingTop||0).toFixed(2)}" min="0"></div>`;
            h += `<div class="prop-grid"><label></label><label>Padding Right</label><input type="number" step="0.1" data-prop="props.paddingRight" value="${Number(el.props.paddingRight||0).toFixed(2)}" min="0"></div>`;
            h += `<div class="prop-grid"><label></label><label>Padding Bottom</label><input type="number" step="0.1" data-prop="props.paddingBottom" value="${Number(el.props.paddingBottom||0).toFixed(2)}" min="0"></div>`;
            h += `<div class="prop-grid"><label></label><label>Padding Left</label><input type="number" step="0.1" data-prop="props.paddingLeft" value="${Number(el.props.paddingLeft||0).toFixed(2)}" min="0"></div>`;
        }

        // border + rotation
        h += `<hr><div class="prop-grid"><label>Show Border</label><input type="checkbox" data-prop="props.showBorder" ${el.props.showBorder?'checked':''}><label>Border Color</label><input type="color" data-prop="props.borderColor" value="${el.props.borderColor||'#000000'}"></div>`;
        h += `<div class="prop-grid"><label>Border Width</label><input type="number" data-prop="props.borderWidth" value="${el.props.borderWidth||1}" min="0"><label>Rotation¬∞</label><input type="number" step="1" data-prop="props.rotation" value="${el.props.rotation||0}"></div>`;
        if(el.type!=='box') h += `<hr><label>Color</label><input type="color" data-prop="props.color" value="${el.props.color||'#000000'}">`;
        h += `<hr><button id="btn-delete">Delete Element</button>`;
        pp.innerHTML = h;
    }

    function multiPropsPanel(elems){
        function common(propPath){
            const parts = propPath.split('.');
            let val = undefined;
            for(const el of elems){
                let cur = el;
                for(const p of parts){
                    if(cur && Object.prototype.hasOwnProperty.call(cur,p)) cur = cur[p]; else { cur = undefined; break; }
                }
                if(val === undefined) val = cur;
                else if(String(val) !== String(cur)) return '';
            }
            return val === undefined ? '' : val;
        }

        let h = `<div style="font-weight:600;margin-bottom:6px">${elems.length} elements selected</div>`;
        h += `<div class="prop-grid"><label>X</label><input type="number" step="0.1" data-prop="multi.x" value="${common('x')}"><label>Y</label><input type="number" step="0.1" data-prop="multi.y" value="${common('y')}"></div>`;
        h += `<div class="prop-grid"><label>Width</label><input type="number" step="0.1" data-prop="multi.width" value="${common('width')}"><label>Height</label><input type="number" step="0.1" data-prop="multi.height" value="${common('height')}"></div><hr>`;
        h += `<div class="prop-grid"><label>Font Size</label><input type="number" data-prop="multi.props.fontSize" value="${common('props.fontSize')}" min="6"><label>Font Weight</label><select data-prop="multi.props.fontWeight"><option value="">‚Äî</option><option value="normal" ${common('props.fontWeight')==='normal'?'selected':''}>Normal</option><option value="bold" ${common('props.fontWeight')==='bold'?'selected':''}>Bold</option></select></div>`;
        h += `<div class="prop-grid"><label>Align</label><select data-prop="multi.props.textAlign"><option value="">‚Äî</option><option value="left" ${common('props.textAlign')==='left'?'selected':''}>Left</option><option value="center" ${common('props.textAlign')==='center'?'selected':''}>Center</option><option value="right" ${common('props.textAlign')==='right'?'selected':''}>Right</option></select><label>Vertical Align</label><select data-prop="multi.props.valign"><option value="">‚Äî</option><option value="top" ${common('props.valign')==='top'?'selected':''}>Top</option><option value="middle" ${common('props.valign')==='middle'?'selected':''}>Middle</option><option value="bottom" ${common('props.valign')==='bottom'?'selected':''}>Bottom</option></select></div>`;
        h += `<div class="prop-grid"><label>Padding Top</label><input type="number" step="0.1" data-prop="multi.props.paddingTop" value="${common('props.paddingTop')}" min="0"><label>Padding Right</label><input type="number" step="0.1" data-prop="multi.props.paddingRight" value="${common('props.paddingRight')}" min="0"></div>`;
        h += `<div class="prop-grid"><label>Padding Bottom</label><input type="number" step="0.1" data-prop="multi.props.paddingBottom" value="${common('props.paddingBottom')}" min="0"><label>Padding Left</label><input type="number" step="0.1" data-prop="multi.props.paddingLeft" value="${common('props.paddingLeft')}" min="0"></div>`;
        h += `<div class="prop-grid"><label>Rotation¬∞</label><input type="number" step="1" data-prop="multi.props.rotation" value="${common('props.rotation')}"><label>Show Border</label><input type="checkbox" data-prop="multi.props.showBorder" ${common('props.showBorder')?'checked':''}></div>`;
        h += `<div class="prop-grid"><label>Border Color</label><input type="color" data-prop="multi.props.borderColor" value="${common('props.borderColor')||'#000000'}"><label>Border Width</label><input type="number" data-prop="multi.props.borderWidth" value="${common('props.borderWidth')}" min="0"></div>`;
        h += `<div class="prop-grid"><label>Color</label><input type="color" data-prop="multi.props.color" value="${common('props.color')||'#000000'}"><label></label></div>`;
        h += `<hr><button id="btn-delete">Delete Selected</button>`;
        pp.innerHTML = h;
    }

    function escapeHtml(str){ if(str===null||str===undefined) return ''; return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }

    // ---------- Improved column search ----------
    function searchColumns(query, columns){
        if(!query || !query.trim()) return columns.map(col => ({ col, score: 0 }));
        const q = query.toLowerCase().trim();
        const queryWords = q.split(/\s+/).filter(w => w.length > 0);
        
        return columns.map(col => {
            const colLower = col.toLowerCase();
            let score = 0;
            
            // Exact match (highest priority)
            if(colLower === q){
                score = 1000;
            }
            // Starts with query
            else if(colLower.startsWith(q)){
                score = 500;
            }
            // Contains query as whole substring
            else if(colLower.includes(q)){
                score = 300;
            }
            // All query words present in order (multi-word search)
            else if(queryWords.length > 1){
                const allWordsPresent = queryWords.every(word => colLower.includes(word));
                if(allWordsPresent){
                    // Check if words appear in order (bonus points)
                    let lastIndex = -1;
                    let inOrder = true;
                    for(const word of queryWords){
                        const idx = colLower.indexOf(word, lastIndex + 1);
                        if(idx === -1){
                            inOrder = false;
                            break;
                        }
                        lastIndex = idx;
                    }
                    score = inOrder ? 250 : 200;
                }
            }
            // Single word: check if it matches word boundaries or parts
            else if(queryWords.length === 1){
                const word = queryWords[0];
                // Check word boundary matches (e.g., "name" matches "full_name" or "name_field")
                const wordBoundaryRegex = new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i');
                if(wordBoundaryRegex.test(col)){
                    score = 400;
                }
                // Check if word appears as part of another word
                else if(colLower.includes(word)){
                    score = 150;
                }
            }
            
            // Fuzzy matching: check if all characters of query appear in order in column name
            if(score === 0){
                let queryIdx = 0;
                for(let i = 0; i < colLower.length && queryIdx < q.length; i++){
                    if(colLower[i] === q[queryIdx]){
                        queryIdx++;
                    }
                }
                if(queryIdx === q.length){
                    score = 50; // All characters found in order
                }
            }
            
            return { col, score };
        })
        .filter(result => result.score > 0)
        .sort((a, b) => {
            // Sort by score (descending), then alphabetically for same score
            if(b.score !== a.score) return b.score - a.score;
            return a.col.localeCompare(b.col);
        });
    }

    // ---------- Element operations (multi-aware) ----------
    function pushBeforeChange(){ pushHistorySnapshot(); }
    function pushAfterChange(){ /* placeholder */ }

    function add(type){
        pushBeforeChange();
        const mz = S.length>0 ? Math.max(...S.map(e=>e.zIndex||0)) : 0;
        const n = {
            id: `el_${Date.now()}`,
            type,
            x:.5,y:.5,width:1.5,height:.5,zIndex:mz+1,
            props:{
                text:'Sample Text',fontSize:16,fontWeight:'normal',fontFamily:'Arial, sans-serif',
                textAlign:'left',valign:'top',color:'#000000',boundColumn:'',prefix:'',suffix:'',
                rotation:0,showBorder:false,borderColor:'#000',borderWidth:1,
                paddingTop:0,paddingRight:0,paddingBottom:0,paddingLeft:0,
                thickness:2,format:'CODE128',displayValue:true,fillColor:'#fff',decimals:2,asPercent:false
            }
        };
        if(type==='qr'){ n.width=1;n.height=1 }
        if(type==='barcode'){ n.width=2;n.height=.8 }
        if(type==='line'){ n.height=.02;n.width=2 }
        if(type==='box'){ n.width=1.5;n.height=1 }
        S.push(n);
        setSelection([n.id]);
        pushAfterChange();
        saveCurrentDesign();
        save();
    }

    function dupSelected(){
        if(selectedIds.length===0) return;
        pushBeforeChange();
        const mz = S.length>0 ? Math.max(...S.map(e=>e.zIndex||0)) : 0;
        const newIds = [];
        selectedIds.forEach((id, idx)=>{
            const el = S.find(e=>e.id===id);
            if(!el) return;
            const copy = deepCopy(el);
            copy.id = `el_${Date.now()}_${idx}`;
            copy.x = Math.min(el.x + 0.2, W - el.width);
            copy.y = Math.min(el.y + 0.2, H - el.height);
            copy.zIndex = mz + idx + 1;
            S.push(copy);
            newIds.push(copy.id);
        });
        setSelection(newIds);
        pushAfterChange();
        saveCurrentDesign();
        save();
    }

    function bringToFront(){
        if(selectedIds.length===0) return;
        pushBeforeChange();
        let mz = S.length>0 ? Math.max(...S.map(e=>e.zIndex||0)) : 0;
        selectedIds.forEach(id=>{
            const el = S.find(e=>e.id===id);
            if(el){ mz++; el.zIndex = mz; }
        });
        render(); saveCurrentDesign(); save(); pushAfterChange();
    }

    function sendToBack(){
        if(selectedIds.length===0) return;
        pushBeforeChange();
        let mn = S.length>0 ? Math.min(...S.map(e=>e.zIndex||0)) : 0;
        selectedIds.forEach((id, idx)=>{
            const el = S.find(e=>e.id===id);
            if(el){ el.zIndex = mn - (idx+1); }
        });
        render(); saveCurrentDesign(); save(); pushAfterChange();
    }

    function deleteSelected(){
        if(selectedIds.length===0) return;
        pushBeforeChange();
        S = S.filter(e => !selectedIds.includes(e.id));
        selectedIds = [];
        render(); updateProps(); updateBtns();
        pushAfterChange();
        saveCurrentDesign();
        save();
    }

    // ---------- Save / Load ----------
    async function save(){
        // Save current design before saving all profiles
        saveCurrentDesign();
        const payloadObj = { 
            version: 2, 
            timestamp: Date.now(), 
            profiles: profiles,
            currentProfile: currentProfile,
            currentDesign: currentDesign
        };
        const payload = JSON.stringify(payloadObj);
        try{ localStorage.setItem(KEY, payload); } catch(e){ console.warn('localStorage.setItem failed:',e) }
        if(isGristAvailable()){
            try{ await window.grist.setOption(KEY,payload); msg('Layout saved successfully!'); return true; }
            catch(e){ console.warn('Grist.setOption failed',e); msg('Layout saved locally (Grist unavailable).',false,2000); return false; }
        } else { msg('Layout saved locally.', false, 1500); return false; }
    }

    async function load(fromFileContent){
        let raw = null;
        if(fromFileContent) raw = fromFileContent;
        else if(isGristAvailable()){
            try{ raw = await window.grist.getOption(KEY); if(raw && typeof raw === 'object' && raw.value !== undefined) raw = raw.value; }catch(e){ console.warn("Grist.getOption failed:",e); raw=null; }
        }
        if(!raw){
            try{ raw = localStorage.getItem(KEY); }catch(e){ console.warn("localStorage.getItem failed:",e); raw=null; }
        }
        if(!raw){ 
            // Try loading old format
            try{ raw = localStorage.getItem('grist_label_layout_v1'); }catch(e){}
            if(!raw){
                msg('No saved layout found. Use Import or create elements.'); 
                return false; 
            }
        }
        try{
            let parsed = JSON.parse(raw);
            
            // Handle new format (v2) with profiles
            if(parsed && parsed.version === 2 && parsed.profiles){
                profiles = parsed.profiles;
                currentProfile = parsed.currentProfile || Object.keys(profiles)[0] || '8x5';
                currentDesign = parsed.currentDesign || 'default';
                
                // Ensure current profile/design exist
                if(!profiles[currentProfile]){
                    currentProfile = Object.keys(profiles)[0] || '8x5';
                }
                if(!profiles[currentProfile].designs[currentDesign]){
                    currentDesign = Object.keys(profiles[currentProfile].designs)[0] || 'default';
                }
                
                loadCurrentDesign();
                updateCanvasSize();
                updateProfileSelector();
                updateDesignSelector();
            }
            // Handle old format (v1) - migrate to new format
            else if(parsed && (parsed.data || Array.isArray(parsed) || parsed.layout)){
                const oldData = parsed.data || (Array.isArray(parsed) ? parsed : parsed.layout);
                // Migrate old layout to default profile/design
                profiles = {
                    '8x5': {
                        width: 8,
                        height: 5,
                        designs: {
                            'default': oldData.map(normalizeElement)
                        }
                    }
                };
                currentProfile = '8x5';
                currentDesign = 'default';
                loadCurrentDesign();
                updateCanvasSize();
                updateProfileSelector();
                updateDesignSelector();
                msg('Layout migrated to new format');
            }
            else {
                throw new Error('Unknown layout structure');
            }
            
            selectedIds = [];
            render(); updateProps(); updateBtns();
            resetHistory();
            msg('Layout loaded successfully!');
            return true;
        }catch(e){
            console.error('Parse error while loading layout:',e);
            msg('Error loading layout: invalid JSON', true, 4000);
            return false;
        }
    }

    function exportToFile(){
        saveCurrentDesign();
        const payloadObj = { 
            version: 2, 
            timestamp: Date.now(), 
            profiles: profiles,
            currentProfile: currentProfile,
            currentDesign: currentDesign
        };
        const blob = new Blob([JSON.stringify(payloadObj,null,2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'label-layout.json';
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    // ---------- Mouse interactions: marquee, selection, drag, resize ----------
    lc.addEventListener('mousedown', (e)=>{
        const t = e.target;
        // If clicking on the background of label-canvas, start marquee selection
        if(t === lc){
            // start marquee - compute coordinates relative to canvas-container (so zoom & transform do not misplace)
            const containerRect = cc.getBoundingClientRect();
            marqueeActive = true;
            marqueeStart.clientX = e.clientX;
            marqueeStart.clientY = e.clientY;
            // startX/startY in pixels relative to container
            marqueeStart.startX = e.clientX - containerRect.left;
            marqueeStart.startY = e.clientY - containerRect.top;
            marqueeStart.containerRect = containerRect;
            marquee.style.display = 'block';
            marquee.style.left = `${marqueeStart.startX}px`;
            marquee.style.top = `${marqueeStart.startY}px`;
            marquee.style.width = '0px';
            marquee.style.height = '0px';
            // do not immediately clear selection; selection will be applied on mouseup (unless ctrl/meta is not pressed - behavior preserved)
            e.preventDefault();
            return;
        }

        // clicked element
        const te = t.closest('.label-element');
        if(!te) return;
        const id = te.dataset.id;
        const clickedElement = S.find(x=>x.id===id);
        if(!clickedElement) return;

        // selection logic
        if(e.ctrlKey || e.metaKey){
            pushBeforeChange();
            toggleSelection(id);
        } else {
            if(!selectedIds.includes(id)){
                pushBeforeChange();
                setSelection([id]);
            }
        }

        const cr = lc.getBoundingClientRect();
        const smx = (e.clientX - cr.left) / cr.width * W;
        const smy = (e.clientY - cr.top) / cr.height * H;

        if(t.classList.contains('resize-handle') && selectedIds.length <= 1){
            resizeMode = true;
            ctx = { el: clickedElement, startWidth: clickedElement.width, startHeight: clickedElement.height, startMouseX: smx, startMouseY: smy };
        } else {
            drag = true;
            const movers = selectedIds.includes(id) ? selectedIds.slice() : [id];
            const items = movers.map(iid => S.find(s => s.id === iid)).filter(Boolean);
            ctx = { items: items.map(it => ({ id: it.id, startX: it.x, startY: it.y })), baseMouseX: smx, baseMouseY: smy };
            pushBeforeChange();
        }
        e.preventDefault();
    });

    window.addEventListener('mousemove', (e)=>{
        // marquee active handling: draw marquee relative to container (so zoom/transform doesn't misplace)
        if(marqueeActive){
            const containerRect = marqueeStart.containerRect || cc.getBoundingClientRect();
            const curX = e.clientX - containerRect.left;
            const curY = e.clientY - containerRect.top;
            const left = Math.min(marqueeStart.startX, curX);
            const top = Math.min(marqueeStart.startY, curY);
            const width = Math.abs(curX - marqueeStart.startX);
            const height = Math.abs(curY - marqueeStart.startY);
            marquee.style.left = `${left}px`;
            marquee.style.top = `${top}px`;
            marquee.style.width = `${width}px`;
            marquee.style.height = `${height}px`;
            return;
        }

        if(!drag && !resizeMode) return;
        const cr = lc.getBoundingClientRect();
        const mx = (e.clientX - cr.left) / cr.width * W;
        const my = (e.clientY - cr.top) / cr.height * H;

        if(drag && ctx && ctx.items){
            const dx = mx - ctx.baseMouseX;
            const dy = my - ctx.baseMouseY;
            ctx.items.forEach(it=>{
                const el = S.find(s=>s.id===it.id);
                if(!el) return;
                el.x = Math.max(0, Math.min(it.startX + dx, W - el.width));
                el.y = Math.max(0, Math.min(it.startY + dy, H - el.height));
            });
            render();
            updateProps();
        } else if(resizeMode && ctx && ctx.el){
            const dx = mx - ctx.startMouseX;
            const dy = my - ctx.startMouseY;
            let nw = ctx.startWidth + dx;
            let nh = ctx.startHeight + dy;
            ctx.el.width = Math.max(.2, Math.min(nw, W - ctx.el.x));
            ctx.el.height = Math.max(.2, Math.min(nh, H - ctx.el.y));
            render();
            updateProps();
        }
    });

    window.addEventListener('mouseup', (e)=>{
        if(marqueeActive){
            // compute selection rectangle intersection using label-canvas bounding rect (this respects zoom)
            const rect = lc.getBoundingClientRect();
            const x1 = marqueeStart.clientX, y1 = marqueeStart.clientY;
            const x2 = e.clientX, y2 = e.clientY;
            // determine screen-space selection bounds
            const leftPx = Math.min(x1,x2);
            const topPx = Math.min(y1,y2);
            const rightPx = Math.max(x1,x2);
            const bottomPx = Math.max(y1,y2);
            // clamp to label-canvas
            const selLeft = Math.max(leftPx, rect.left);
            const selTop = Math.max(topPx, rect.top);
            const selRight = Math.min(rightPx, rect.right);
            const selBottom = Math.min(bottomPx, rect.bottom);

            let selected = [];
            if(selRight > selLeft && selBottom > selTop){
                const fracLeft = (selLeft - rect.left) / rect.width;
                const fracTop = (selTop - rect.top) / rect.height;
                const fracRight = (selRight - rect.left) / rect.width;
                const fracBottom = (selBottom - rect.top) / rect.height;
                const cmLeft = fracLeft * W;
                const cmTop = fracTop * H;
                const cmRight = fracRight * W;
                const cmBottom = fracBottom * H;

                // select elements whose rectangles intersect the selection rect
                S.forEach(el=>{
                    const elLeft = el.x;
                    const elTop = el.y;
                    const elRight = el.x + el.width;
                    const elBottom = el.y + el.height;
                    const intersect = !(elRight < cmLeft || elLeft > cmRight || elBottom < cmTop || elTop > cmBottom);
                    if(intersect) selected.push(el.id);
                });
            }

            // ctrl/meta -> toggle behavior; otherwise replace selection
            if(e.ctrlKey || e.metaKey){
                selected.forEach(id=>{
                    const i = selectedIds.indexOf(id);
                    if(i===-1) selectedIds.push(id); else selectedIds.splice(i,1);
                });
            } else {
                selectedIds = selected;
            }

            marqueeActive = false;
            marquee.style.display = 'none';
            render();
            updateProps();
            updateBtns();
            save();
            e.preventDefault();
            return;
        }

        if(drag || resizeMode){
            save();
            pushAfterChange();
        }
        drag = false; resizeMode = false; ctx = {};
    });

    // ---------- Keyboard shortcuts (undo/redo/multi) ----------
    window.addEventListener('keydown', (e)=>{
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z'){
            e.preventDefault();
            if(e.shiftKey) redo(); else undo();
            return;
        }
        if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y'){
            e.preventDefault(); redo(); return;
        }

        if((e.key === 'Delete' || e.key === 'Backspace') && selectedIds.length>0){
            if(e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA'){ e.preventDefault(); deleteSelected(); }
        }

        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
            if(e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA'){
                if(selectedIds.length>0){
                    e.preventDefault();
                    const step = e.shiftKey ? 0.1 : 0.01;
                    pushBeforeChange();
                    selectedIds.forEach(id=>{
                        const el = S.find(s=>s.id===id); if(!el) return;
                        switch(e.key){
                            case 'ArrowUp': el.y = Math.max(0, el.y - step); break;
                            case 'ArrowDown': el.y = Math.min(H - el.height, el.y + step); break;
                            case 'ArrowLeft': el.x = Math.max(0, el.x - step); break;
                            case 'ArrowRight': el.x = Math.min(W - el.width, el.x + step); break;
                        }
                    });
                    render(); updateProps(); save(); pushAfterChange();
                }
            }
        }

        if((e.ctrlKey||e.metaKey) && e.key.toLowerCase() === 'd'){
            e.preventDefault();
            dupSelected();
        }
    });

    // ---------- Property edits (apply to single or multiple) ----------
    pp.addEventListener('input', (e)=>{
        if(selectedIds.length === 0 && e.target.dataset.prop !== 'bind_search') return;
        const target = e.target;
        const prop = target.dataset.prop;
        if(!prop) return;

        // Handle bound column search input
        if(prop === 'bind_search'){
            // Clear previous debounce timer
            if(searchDebounceTimer) clearTimeout(searchDebounceTimer);
            
            const query = String(target.value || '').trim();
            const select = pp.querySelector('select[data-prop="props.boundColumn"]');
            if(!select) return;
            
            // Debounce search for better performance
            searchDebounceTimer = setTimeout(() => {
                if(!query){
                    // No query - show all columns
                    select.innerHTML = `<option value="">-- Select Column --</option>${C.map(col => `<option value="${col}" ${select.value===col?'selected':''}>${col}</option>`).join('')}`;
                } else {
                    // Use improved search
                    const results = searchColumns(query, C);
                    if(results.length === 0){
                        select.innerHTML = `<option value="">-- No matches found --</option>`;
                    } else {
                        select.innerHTML = `<option value="">-- Select Column (${results.length} found) --</option>${results.map(({col}) => `<option value="${col}" ${select.value===col?'selected':''}>${col}</option>`).join('')}`;
                    }
                }
            }, 150); // 150ms debounce
            return;
        }

        if(prop.startsWith('multi.')){
            const keyPath = prop.slice('multi.'.length);
            const value = (target.type === 'checkbox') ? target.checked : (target.type === 'number' ? Number(target.value) : target.value);
            pushBeforeChange();
            selectedIds.forEach(id=>{
                const el = S.find(s=>s.id===id);
                if(!el) return;
                if(keyPath.includes('.')){
                    const [o,k] = keyPath.split('.');
                    if(!el[o]) el[o] = {};
                    if(['fontSize','decimals','thickness','borderWidth','rotation','paddingTop','paddingRight','paddingBottom','paddingLeft','x','y','width','height'].includes(k)) el[o][k] = Number(value);
                    else if(['showBorder','displayValue','asPercent'].includes(k)) el[o][k] = !!value;
                    else el[o][k] = value;
                } else {
                    if(['x','y','width','height','zIndex'].includes(keyPath)) el[keyPath] = Number(value);
                    else el[keyPath] = value;
                }
            });
            render(); updateProps(); save(); pushAfterChange();
            return;
        }

        const applyToAll = selectedIds.length > 1;
        const parsedValue = (target.type === 'checkbox') ? target.checked : (target.type === 'number' ? Number(target.value) : target.value);

        function applyPropToElement(el, p, v){
            if(p === 'widthHeight'){ el.height = Number(v); return; }
            if(p.includes('.')){
                const [o,k] = p.split('.');
                if(!el[o]) el[o] = {};
                if(['fontSize','decimals','thickness','borderWidth','rotation','paddingTop','paddingRight','paddingBottom','paddingLeft','x','y','width','height'].includes(k)) el[o][k] = Number(v);
                else if(['showBorder','displayValue','asPercent'].includes(k)) el[o][k] = !!v;
                else el[o][k] = v;
            } else {
                if(['x','y','width','height','zIndex'].includes(p)) el[p] = Number(v);
                else el[p] = v;
            }
        }

        pushBeforeChange();
        if(applyToAll){
            selectedIds.forEach(id=>{
                const el = S.find(s=>s.id===id); if(!el) return;
                applyPropToElement(el, prop, parsedValue);
            });
        } else {
            const id = selectedIds[0];
            const el = S.find(s=>s.id===id);
            if(el) applyPropToElement(el, prop, parsedValue);
        }
        render(); 
        saveCurrentDesign(); 
        save(); 
        pushAfterChange();
    });

    pp.addEventListener('click', (e)=>{
        if(e.target && e.target.id === 'btn-delete'){
            deleteSelected();
        }
    });

    // ---------- Buttons ----------
    document.getElementById('btn-save').addEventListener('click', ()=> save());
    document.getElementById('btn-load').addEventListener('click', async ()=>{
        const ok = await load();
        if(!ok){ fileInput.value = ''; fileInput.click(); }
    });
    document.getElementById('btn-print').addEventListener('click', ()=>{
        const prevSel = deepCopy(selectedIds);
        selectedIds = []; render();
        window.print();
        setTimeout(()=>{ selectedIds = prevSel; render(); }, 100);
    });
    document.getElementById('btn-clear').addEventListener('click', ()=>{
        if(confirm('Are you sure you want to clear the layout?')){
            pushBeforeChange();
            S=[]; selectedIds=[];
            render(); updateProps(); updateBtns();
            pushAfterChange();
            saveCurrentDesign();
            save();
        }
    });
    bd.addEventListener('click', dupSelected);
    bf.addEventListener('click', bringToFront);
    bs.addEventListener('click', sendToBack);
    document.getElementById('btn-zoom-in').addEventListener('click', ()=> setZoom(z*1.25));
    document.getElementById('btn-zoom-out').addEventListener('click', ()=> setZoom(z/1.25));
    document.getElementById('btn-zoom-fit').addEventListener('click', fit);

    document.querySelectorAll('.add-element').forEach(b=> b.addEventListener('click', e => add(e.currentTarget.dataset.type)));

    btnExport.addEventListener('click', ()=>{ exportToFile(); msg('Layout exported to file.'); });
    btnImport.addEventListener('click', ()=>{ fileInput.value=''; fileInput.click(); });

    // Profile/Design management
    profileSelector.addEventListener('change', (e)=>{
        switchProfile(e.target.value);
        save();
    });
    designSelector.addEventListener('change', (e)=>{
        switchDesign(e.target.value);
        save();
    });
    btnAddProfile.addEventListener('click', ()=>{
        addProfile();
    });
    btnAddDesign.addEventListener('click', ()=>{
        addDesign();
    });
    btnRemoveProfile.addEventListener('click', ()=>{
        removeProfile();
    });
    btnRemoveDesign.addEventListener('click', ()=>{
        removeDesign();
    });
    fileInput.addEventListener('change', (ev)=>{
        const f = ev.target.files && ev.target.files[0];
        if(!f) return;
        const reader = new FileReader();
        reader.onload = function(e){ load(e.target.result); };
        reader.readAsText(f);
    });

    window.addEventListener('keydown', (e)=>{
        if((e.ctrlKey||e.metaKey) && e.key.toLowerCase() === 'e'){ e.preventDefault(); exportToFile(); msg('Layout exported to file.'); }
    });

    // ---------- Zoom / fit ----------
    function setZoom(nz){ z = Math.max(.1, Math.min(3, nz)); cw.style.transform = `scale(${z})`; zd.textContent = `${Math.round(z*100)}%`; }
    function fit(){ const cr = cc.getBoundingClientRect(); const hw = (cr.width-40)/(W*37.795276); const vw = (cr.height-40)/(H*37.795276); setZoom(Math.min(hw,vw,1.5)); }

    // ---------- Grist integration (optional) ----------
    if(isGristAvailable()){
        try{ window.grist.ready({ requiredAccess:'full' }); }catch(e){}
        try{
            if(typeof window.grist.onRecord === 'function'){
                window.grist.onRecord(function(record,mappings){ R = record||{}; C = Object.keys(R); if(selectedIds.length) updateProps(); render(); });
            }
        }catch(e){ console.warn('grist.onRecord error',e); }
        try{
            if(typeof window.grist.onOptions === 'function'){
                window.grist.onOptions(function(options){ /* no-op */ });
            }
        }catch(e){}
    } else { R = {}; C = []; }

    // ---------- Initial load & history init ----------
    // Initialize canvas size immediately
    updateCanvasSize();
    updateProfileSelector();
    updateDesignSelector();
    
    setTimeout(()=>{ 
        load().then(()=> {
            updateCanvasSize();
            updateProfileSelector();
            updateDesignSelector();
            fit();
        }); 
    }, 120);
    resetHistory();

}); // DOMContentLoaded
</script>

</body>
</html>